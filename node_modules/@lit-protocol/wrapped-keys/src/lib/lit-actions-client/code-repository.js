"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.litActionCodeRepositoryCommon = exports.litActionCodeRepository = void 0;
exports.setLitActionsCode = setLitActionsCode;
exports.setLitActionsCodeCommon = setLitActionsCodeCommon;
/**
 * A repository for managing Lit Actions related to blockchain operations.
 * The repository provides functionalities for handling transactions, messages,
 * encrypted keys, and private keys across multiple blockchain platforms.
 * @type {LitActionCodeRepository}
 */
const litActionCodeRepository = Object.freeze({
    signTransaction: Object.seal({
        evm: '',
        solana: '',
    }),
    signMessage: Object.seal({
        evm: '',
        solana: '',
    }),
    generateEncryptedKey: Object.seal({
        evm: '',
        solana: '',
    }),
    exportPrivateKey: Object.seal({
        evm: '',
        solana: '',
    }),
});
exports.litActionCodeRepository = litActionCodeRepository;
function assertIsLitActionKey(key) {
    if (!(key in litActionCodeRepository)) {
        throw new Error(`Invalid key: ${key}; must be one of ${Object.keys(litActionCodeRepository).join(',')}`);
    }
}
/**
 * Type Guard for LitActionCodeRepositoryEntry
 */
function assertIsLitActionRepositoryEntry(entry) {
    if (typeof entry !== 'object' ||
        !entry ||
        ('evm' in entry && typeof entry.evm !== 'string') ||
        ('solana' in entry && typeof entry.solana !== 'string') ||
        Object.keys(entry).some((key) => !['evm', 'solana'].includes(key))) {
        throw new Error(`Invalid LitActionRepository entry: ${JSON.stringify(entry)}`);
    }
}
/**
 * Updates the litActionCodeRepository with the provided entries.
 * @param { LitActionCodeRepositoryInput } repository - user provided repository to set
 */
function setLitActionsCode(repository) {
    for (const [actionType, actionCode] of Object.entries(repository)) {
        assertIsLitActionKey(actionType);
        assertIsLitActionRepositoryEntry(actionCode);
        for (const [network, code] of Object.entries(actionCode)) {
            litActionCodeRepository[actionType][network] =
                code;
        }
    }
}
/**
 * A repository for managing Lit Actions related to blockchain operations.
 * Contains actions that are designed to be used for multiple networks
 * @type {LitActionCodeRepositoryCommon}
 */
const litActionCodeRepositoryCommon = {
    batchGenerateEncryptedKeys: '',
};
exports.litActionCodeRepositoryCommon = litActionCodeRepositoryCommon;
function assertIsLitActionKeyCommon(key) {
    if (!(key in litActionCodeRepositoryCommon)) {
        throw new Error(`Invalid key: ${key}; must be one of ${Object.keys(litActionCodeRepositoryCommon).join(',')}`);
    }
}
/**
 * Type Guard for LitActionCodeRepositoryEntry
 */
function assertIsLitActionRepositoryEntryCommon(entry) {
    if (typeof entry !== 'string') {
        throw new Error(`Invalid LitActionRepositoryCommon entry: ${JSON.stringify(entry)}`);
    }
}
/**
 * Updates the litActionCodeRepository with the provided entries.
 * @param { LitActionCodeRepositoryCommonInput } repository - user provided repository to set
 */
function setLitActionsCodeCommon(repository) {
    for (const [actionType, actionCode] of Object.entries(repository)) {
        assertIsLitActionKeyCommon(actionType);
        assertIsLitActionRepositoryEntryCommon(actionCode);
        litActionCodeRepositoryCommon[actionType] = actionCode;
    }
}
//# sourceMappingURL=code-repository.js.map