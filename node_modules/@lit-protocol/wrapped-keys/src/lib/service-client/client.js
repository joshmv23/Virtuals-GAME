"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPrivateKeyMetadata = listPrivateKeyMetadata;
exports.fetchPrivateKey = fetchPrivateKey;
exports.storePrivateKey = storePrivateKey;
exports.storePrivateKeyBatch = storePrivateKeyBatch;
const utils_1 = require("./utils");
/** Fetches previously stored private key metadata from the wrapped keys service.
 * Note that this list will not include `cipherText` or `dataToEncryptHash` necessary to decrypt the keys.
 * Use `fetchPrivateKey()` to get those values.
 *
 * @param { FetchKeyParams } params Parameters required to fetch the private key metadata
 * @returns { Promise<StoredKeyMetadata[]> } The private key metadata object
 */
async function listPrivateKeyMetadata(params) {
    const { litNetwork, sessionSig, pkpAddress } = params;
    const requestId = (0, utils_1.generateRequestId)();
    const { baseUrl, initParams } = (0, utils_1.getBaseRequestParams)({
        litNetwork,
        sessionSig,
        method: 'GET',
        requestId,
    });
    return (0, utils_1.makeRequest)({
        url: `${baseUrl}/${pkpAddress}`,
        init: initParams,
        requestId,
    });
}
/** Fetches complete previously stored private key data from the wrapped keys service.
 * Includes the `ciphertext` and `dataToEncryptHash` necessarily to decrypt the key.
 *
 * @param { FetchKeyParams } params Parameters required to fetch the private key data
 * @returns { Promise<StoredKeyData> } The private key metadata object
 */
async function fetchPrivateKey(params) {
    const { litNetwork, sessionSig, id, pkpAddress } = params;
    const requestId = (0, utils_1.generateRequestId)();
    const { baseUrl, initParams } = (0, utils_1.getBaseRequestParams)({
        litNetwork,
        sessionSig,
        method: 'GET',
        requestId,
    });
    return (0, utils_1.makeRequest)({
        url: `${baseUrl}/${pkpAddress}/${id}`,
        init: initParams,
        requestId,
    });
}
/** Stores private key metadata into the wrapped keys service backend
 *
 * @param { StoreKeyParams } params Parameters required to store the private key metadata
 * @returns { Promise<StoreEncryptedKeyResult> } `true` on successful write to the service. Otherwise, this method throws an error.
 */
async function storePrivateKey(params) {
    const { litNetwork, sessionSig, storedKeyMetadata } = params;
    const requestId = (0, utils_1.generateRequestId)();
    const { baseUrl, initParams } = (0, utils_1.getBaseRequestParams)({
        litNetwork,
        sessionSig,
        method: 'POST',
        requestId,
    });
    const { pkpAddress, id } = await (0, utils_1.makeRequest)({
        url: baseUrl,
        init: {
            ...initParams,
            body: JSON.stringify(storedKeyMetadata),
        },
        requestId,
    });
    return { pkpAddress, id };
}
/** Stores a batch of up to 25 private key metadata into the wrapped keys service backend
 *
 * @param { StoreKeyParams } params Parameters required to store the private key metadata
 * @returns { Promise<StoreEncryptedKeyResult> } `true` on successful write to the service. Otherwise, this method throws an error.
 */
async function storePrivateKeyBatch(params) {
    const { litNetwork, sessionSig, storedKeyMetadataBatch } = params;
    const requestId = (0, utils_1.generateRequestId)();
    const { baseUrl, initParams } = (0, utils_1.getBaseRequestParams)({
        litNetwork,
        sessionSig,
        method: 'POST',
        requestId,
    });
    const { pkpAddress, ids } = await (0, utils_1.makeRequest)({
        url: `${baseUrl}_batch`,
        init: {
            ...initParams,
            body: JSON.stringify({ keyParamsBatch: storedKeyMetadataBatch }),
        },
        requestId,
    });
    return { pkpAddress, ids };
}
//# sourceMappingURL=client.js.map