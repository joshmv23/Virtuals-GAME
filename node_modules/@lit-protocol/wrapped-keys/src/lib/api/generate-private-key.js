"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePrivateKey = generatePrivateKey;
const utils_1 = require("./utils");
const lit_actions_client_1 = require("../lit-actions-client");
const utils_2 = require("../lit-actions-client/utils");
const service_client_1 = require("../service-client");
/**
 * Generates a random private key inside a Lit Action, and persists the key and its metadata to the wrapped keys service.
 * Returns the public key of the random private key, and the PKP address that it was associated with.
 * We don't return the generated wallet address since it can be derived from the publicKey
 *
 * The key will be associated with the PKP address embedded in the `pkpSessionSigs` you provide. One and only one wrapped key can be associated with a given LIT PKP.
 *
 * @param { GeneratePrivateKeyParams } params - Required parameters to generate the private key
 *
 * @returns { Promise<GeneratePrivateKeyResult> } - The publicKey of the generated random private key and the LIT PKP Address associated with the Wrapped Key
 */
async function generatePrivateKey(params) {
    const { pkpSessionSigs, network, litNodeClient, memo } = params;
    const firstSessionSig = (0, utils_1.getFirstSessionSig)(pkpSessionSigs);
    const pkpAddress = (0, utils_1.getPkpAddressFromSessionSig)(firstSessionSig);
    const allowPkpAddressToDecrypt = (0, utils_1.getPkpAccessControlCondition)(pkpAddress);
    const { litActionCode, litActionIpfsCid } = (0, utils_2.getLitActionCodeOrCid)(network, 'generateEncryptedKey');
    const { ciphertext, dataToEncryptHash, publicKey } = await (0, lit_actions_client_1.generateKeyWithLitAction)({
        ...params,
        pkpAddress,
        litActionIpfsCid: litActionCode ? undefined : litActionIpfsCid,
        litActionCode: litActionCode ? litActionCode : undefined,
        accessControlConditions: [allowPkpAddressToDecrypt],
    });
    const { id } = await (0, service_client_1.storePrivateKey)({
        sessionSig: firstSessionSig,
        storedKeyMetadata: {
            ciphertext,
            publicKey,
            keyType: (0, utils_1.getKeyTypeFromNetwork)(network),
            dataToEncryptHash,
            memo,
        },
        litNetwork: litNodeClient.config.litNetwork,
    });
    return {
        pkpAddress,
        id,
        generatedPublicKey: publicKey,
    };
}
//# sourceMappingURL=generate-private-key.js.map