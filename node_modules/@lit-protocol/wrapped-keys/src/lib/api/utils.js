"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeyTypeFromNetwork = getKeyTypeFromNetwork;
exports.getFirstSessionSig = getFirstSessionSig;
exports.getPkpAddressFromSessionSig = getPkpAddressFromSessionSig;
exports.getPkpAccessControlCondition = getPkpAccessControlCondition;
const ethers_1 = require("ethers");
const misc_1 = require("@lit-protocol/misc");
const constants_1 = require("../constants");
function getKeyTypeFromNetwork(network) {
    if (network === constants_1.NETWORK_EVM) {
        return 'K256';
    }
    else if (network === constants_1.NETWORK_SOLANA) {
        return 'ed25519';
    }
    else {
        throw new Error(`Network not implemented ${network}`);
    }
}
/**
 *
 * Extracts the first SessionSig from the SessionSigsMap since we only pass a single SessionSig to the AWS endpoint
 *
 * @param pkpSessionSigs - The PKP sessionSigs (map) used to associate the PKP with the generated private key
 *
 * @returns { AuthSig } - The first SessionSig from the map
 */
function getFirstSessionSig(pkpSessionSigs) {
    const sessionSigsEntries = Object.entries(pkpSessionSigs);
    if (sessionSigsEntries.length === 0) {
        throw new Error(`Invalid pkpSessionSigs, length zero: ${JSON.stringify(pkpSessionSigs)}`);
    }
    const [[, sessionSig]] = sessionSigsEntries;
    (0, misc_1.log)(`Session Sig being used: ${JSON.stringify(sessionSig)}`);
    return sessionSig;
}
/**
 *
 * Extracts the wallet address from an individual SessionSig
 *
 * @param pkpSessionSig - The first PKP sessionSig from the function getFirstSessionSig
 *
 * @returns { string } - The wallet address that signed the capabilites AuthSig (BLS)
 */
function getPkpAddressFromSessionSig(pkpSessionSig) {
    const sessionSignedMessage = JSON.parse(pkpSessionSig.signedMessage);
    const capabilities = sessionSignedMessage.capabilities;
    if (!capabilities || capabilities.length === 0) {
        throw new Error(`Capabilities in the session's signedMessage is empty, but required.`);
    }
    const delegationAuthSig = capabilities.find(({ algo }) => algo === 'LIT_BLS');
    if (!delegationAuthSig) {
        throw new Error('SessionSig is not from a PKP; no LIT_BLS capabilities found');
    }
    const pkpAddress = delegationAuthSig.address;
    (0, misc_1.log)(`pkpAddress to permit decryption: ${pkpAddress}`);
    return pkpAddress;
}
/**
 *
 * Creates the access control condition used to gate the access for Wrapped Key decryption
 *
 * @param { string } pkpAddress - The wallet address of the PKP which can decrypt the encrypted Wrapped Key
 *
 * @returns { AccsDefaultParams } - The access control condition that only allows the PKP address to decrypt
 */
function getPkpAccessControlCondition(pkpAddress) {
    if (!ethers_1.ethers.utils.isAddress(pkpAddress)) {
        throw new Error(`pkpAddress is not a valid Ethereum Address: ${pkpAddress}`);
    }
    return {
        contractAddress: '',
        standardContractType: '',
        chain: constants_1.CHAIN_ETHEREUM,
        method: '',
        parameters: [':userAddress'],
        returnValueTest: {
            comparator: '=',
            value: pkpAddress,
        },
    };
}
//# sourceMappingURL=utils.js.map