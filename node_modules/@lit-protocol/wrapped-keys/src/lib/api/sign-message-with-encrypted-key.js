"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMessageWithEncryptedKey = signMessageWithEncryptedKey;
const utils_1 = require("./utils");
const lit_actions_client_1 = require("../lit-actions-client");
const utils_2 = require("../lit-actions-client/utils");
const service_client_1 = require("../service-client");
/**
 * Signs a message inside the Lit Action using the previously persisted wrapped key associated with the current LIT PK.
 * This method fetches the encrypted key from the wrapped keys service, then executes a Lit Action that decrypts the key inside the LIT action and uses
 * the decrypted key to sign the provided transaction
 *
 * @param { SignMessageWithEncryptedKeyParams } params Parameters to use for signing the message
 *
 * @returns { Promise<string> } - The signed message
 */
async function signMessageWithEncryptedKey(params) {
    const { litNodeClient, network, pkpSessionSigs, id } = params;
    const sessionSig = (0, utils_1.getFirstSessionSig)(pkpSessionSigs);
    const pkpAddress = (0, utils_1.getPkpAddressFromSessionSig)(sessionSig);
    const storedKeyMetadata = await (0, service_client_1.fetchPrivateKey)({
        pkpAddress,
        id,
        sessionSig,
        litNetwork: litNodeClient.config.litNetwork,
    });
    const allowPkpAddressToDecrypt = (0, utils_1.getPkpAccessControlCondition)(storedKeyMetadata.pkpAddress);
    const { litActionCode, litActionIpfsCid } = (0, utils_2.getLitActionCodeOrCid)(network, 'signMessage');
    return (0, lit_actions_client_1.signMessageWithLitAction)({
        ...params,
        litActionIpfsCid: litActionCode ? undefined : litActionIpfsCid,
        litActionCode: litActionCode ? litActionCode : undefined,
        accessControlConditions: [allowPkpAddressToDecrypt],
        pkpSessionSigs,
        storedKeyMetadata,
    });
}
//# sourceMappingURL=sign-message-with-encrypted-key.js.map