"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
const utils_1 = require("ethers/lib/utils");
(async () => {
    const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(pkpToolRegistryContractAddress);
    const isDelegatee = await (0, aw_tool_1.checkLitAuthAddressIsDelegatee)(pkpToolRegistryContract, pkpTokenId);
    if (!isDelegatee) {
        throw new Error(`Session signer ${ethers.utils.getAddress(LitAuth.authSigAddress)} is not a delegatee for PKP ${pkpTokenId}`);
    }
    // Get policy parameters
    const policyParameters = await (0, aw_tool_1.getPolicyParameters)(pkpToolRegistryContract, pkpTokenId, parentToolIpfsCid, delegateeAddress, ['allowedTokens']);
    let allowedTokens = [];
    // Add your policy validation logic here using policyParameters
    for (const parameter of policyParameters) {
        const value = ethers.utils.toUtf8String(parameter.value);
        allowedTokens = JSON.parse(value).map(utils_1.getAddress);
        console.log(`Formatted allowedTokens: ${allowedTokens.join(', ')}`);
    }
    if (allowedTokens.length > 0) {
        console.log(`Checking if ${toolParameters.tokenIn} is an allowed token...`);
        if (!allowedTokens.includes((0, utils_1.getAddress)(toolParameters.tokenIn))) {
            throw new Error(`Token ${toolParameters.tokenIn} not allowed. Allowed tokens: ${allowedTokens.join(', ')}`);
        }
        console.log(`Checking if ${toolParameters.tokenOut} is an allowed token...`);
        if (!allowedTokens.includes((0, utils_1.getAddress)(toolParameters.tokenOut))) {
            throw new Error(`Token ${toolParameters.tokenOut} not allowed. Allowed tokens: ${allowedTokens.join(', ')}`);
        }
    }
})();
