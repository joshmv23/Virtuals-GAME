"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadWrappedKeyFromStorage = loadWrappedKeyFromStorage;
exports.saveWrappedKeyToStorage = saveWrappedKeyToStorage;
exports.loadWrappedKeysFromStorage = loadWrappedKeysFromStorage;
exports.mintWrappedKey = mintWrappedKey;
exports.removeWrappedKeyFromStorage = removeWrappedKeyFromStorage;
const tslib_1 = require("tslib");
const encryption_1 = require("@lit-protocol/encryption");
const web3_js_1 = require("@solana/web3.js");
const aw_tool_1 = require("@lit-protocol/aw-tool");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const ethers = tslib_1.__importStar(require("ethers"));
// In Node.js environment, Solana web3.js will use crypto.webcrypto
if (typeof window === 'undefined' && !global.crypto?.subtle) {
    // Only set if subtle is not available (older Node.js versions)
    Object.defineProperty(global, 'crypto', {
        value: crypto_1.default.webcrypto,
        writable: true,
        configurable: true,
    });
}
const errors_1 = require("./errors");
const api_1 = require("@lit-protocol/wrapped-keys/src/lib/api");
function loadWrappedKeyFromStorage(storage, id) {
    try {
        const wrappedKeys = loadWrappedKeysFromStorage(storage);
        return wrappedKeys.find(wk => wk.id === id) || null;
    }
    catch (error) {
        throw new errors_1.AwSignerError(errors_1.AwSignerErrorType.STORAGE_FAILED_TO_GET_ITEM, 'Failed to retrieve Wrapped Key from storage', {
            details: error,
        });
    }
}
function saveWrappedKeyToStorage(storage, wrappedKey) {
    const wrappedKeys = loadWrappedKeysFromStorage(storage);
    const index = wrappedKeys.findIndex(wk => wk.id === wrappedKey.id);
    if (index === -1) {
        wrappedKeys.push(wrappedKey);
    }
    else {
        wrappedKeys[index] = wrappedKey;
    }
    storage.setItem('wks', JSON.stringify(wrappedKeys));
}
function loadWrappedKeysFromStorage(storage) {
    const wks = storage.getItem('wks');
    if (!wks) {
        return [];
    }
    try {
        return JSON.parse(wks);
    }
    catch (error) {
        throw new errors_1.AwSignerError(errors_1.AwSignerErrorType.STORAGE_FAILED_TO_GET_ITEM, 'Failed to parse wrapped keys from storage', {
            details: error,
        });
    }
}
async function mintWrappedKey(litNodeClient, pkpSessionSigs, pkpTokenId, litNetwork, storage) {
    const solanaKeypair = web3_js_1.Keypair.generate();
    console.log('Solana Keypair:', {
        publicKey: solanaKeypair.publicKey.toString(),
        secretKey: Array.from(solanaKeypair.secretKey)
    });
    const pkpAddress = getPkpAddressFromSessionSigs(pkpSessionSigs);
    console.log('Using PKP address for access control:', pkpAddress);
    // Convert PKP address to tokenId
    const tokenIdBN = ethers.BigNumber.from(pkpTokenId);
    const tokenId = tokenIdBN.toString();
    console.log('Converted PKP address to tokenId:', tokenId);
    const evmControlConditions = (0, aw_tool_1.getAccessControlConditions)(tokenId, litNetwork);
    const { ciphertext, dataToEncryptHash } = await (0, encryption_1.encryptString)({
        evmContractConditions: evmControlConditions,
        dataToEncrypt: Buffer.from(solanaKeypair.secretKey).toString('base64'),
    }, litNodeClient);
    const storeResponse = await (0, api_1.storeEncryptedKey)({
        pkpSessionSigs,
        litNodeClient,
        ciphertext,
        dataToEncryptHash,
        keyType: "ed25519",
        memo: "Agent Wallet Wrapped Key",
        publicKey: solanaKeypair.publicKey.toString(),
    });
    const getEncryptedKeyResponse = await (0, api_1.getEncryptedKey)({
        pkpSessionSigs,
        litNodeClient,
        id: storeResponse.id,
    });
    saveWrappedKeyToStorage(storage, getEncryptedKeyResponse);
    return getEncryptedKeyResponse;
}
function getPkpAddressFromSessionSigs(pkpSessionSigs) {
    const [[, sessionSig]] = Object.entries(pkpSessionSigs);
    if (!sessionSig) {
        throw new Error('No session signatures found');
    }
    const { capabilities } = JSON.parse(sessionSig.signedMessage);
    const pkpCapability = capabilities?.find((cap) => cap.algo === 'LIT_BLS');
    if (!pkpCapability) {
        throw new Error('No PKP capability found in session signatures');
    }
    return pkpCapability.address;
}
function removeWrappedKeyFromStorage(storage, id) {
    const wrappedKeys = loadWrappedKeysFromStorage(storage);
    const newWrappedKeys = wrappedKeys.filter(wk => wk.id !== id);
    storage.setItem('wks', JSON.stringify(newWrappedKeys));
}
