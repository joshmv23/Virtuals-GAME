"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
const utils_1 = require("./utils");
(async () => {
    try {
        console.log(`Using Lit Network: ${LIT_NETWORK}`);
        console.log(`Using PKP Tool Registry Address: ${PKP_TOOL_REGISTRY_ADDRESS}`);
        console.log(`Using Pubkey Router Address: ${aw_tool_1.NETWORK_CONFIG[LIT_NETWORK]
            .pubkeyRouterAddress}`);
        const delegateeAddress = ethers.utils.getAddress(LitAuth.authSigAddress);
        const toolIpfsCid = LitAuth.actionIpfsIds[0];
        const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(PKP_TOOL_REGISTRY_ADDRESS);
        const pkp = await (0, aw_tool_1.getPkpInfo)(params.pkpEthAddress);
        const toolPolicy = await (0, aw_tool_1.fetchToolPolicyFromRegistry)(pkpToolRegistryContract, pkp.tokenId, delegateeAddress, toolIpfsCid);
        if (toolPolicy.enabled &&
            toolPolicy.policyIpfsCid !== undefined &&
            toolPolicy.policyIpfsCid !== '0x' &&
            toolPolicy.policyIpfsCid !== '') {
            console.log(`Executing policy ${toolPolicy.policyIpfsCid}`);
            await Lit.Actions.call({
                ipfsId: toolPolicy.policyIpfsCid,
                params: {
                    parentToolIpfsCid: toolIpfsCid,
                    pkpToolRegistryContractAddress: PKP_TOOL_REGISTRY_ADDRESS,
                    pkpTokenId: pkp.tokenId,
                    delegateeAddress,
                    toolParameters: {
                        amountIn: params.amountIn,
                        tokenIn: params.tokenIn,
                        tokenOut: params.tokenOut,
                    },
                },
            });
        }
        else {
            console.log(`No policy found for tool ${toolIpfsCid} on PKP ${pkp.tokenId} for delegatee ${delegateeAddress}`);
        }
        const solanaKeyPair = await (0, utils_1.createSolanaKeypair)(pkp.tokenId);
        const connection = (0, utils_1.createSolanaConnection)();
        const inputDecimals = await (0, utils_1.getTokenDecimals)(connection, params.tokenIn);
        const atomicAmount = (0, utils_1.toAtomicAmount)(params.amountIn, inputDecimals);
        const quoteResponse = await (0, utils_1.getJupiterQuote)({
            inputMint: params.tokenIn,
            outputMint: params.tokenOut,
            amount: atomicAmount,
            slippageBps: "50" // Default 0.5% slippage
        });
        const transaction = await (0, utils_1.getJupiterSwapTransaction)({
            quoteResponse,
            userPublicKey: solanaKeyPair.publicKey.toString()
        });
        transaction.sign([solanaKeyPair]);
        const txid = await (0, utils_1.signAndSendTransaction)(connection, transaction);
        Lit.Actions.setResponse({
            response: {
                status: 'success',
                message: 'Swap transaction sent successfully',
                txid
            }
        });
    }
    catch (error) {
        const errorDetails = {
            message: error instanceof Error ? error.message : String(error),
            type: error instanceof Error ? error.constructor.name : 'UnknownError',
            ...(error instanceof Error && error.stack && { stack: error.stack })
        };
        Lit.Actions.setResponse({
            response: {
                status: 'error',
                error: 'Transaction failed',
                details: errorDetails
            }
        });
    }
})();
