"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
const web3_js_1 = require("@solana/web3.js");
function hexToBytes(hex) {
    // Remove '0x' prefix if present
    hex = hex.startsWith('0x') ? hex.slice(2) : hex;
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
}
function cleanDecodedString(str) {
    // Remove null bytes and trim whitespace
    return str.replace(/\0/g, '').trim();
}
function validateToken(token, allowedTokens, tokenType) {
    try {
        const tokenPubkey = new web3_js_1.PublicKey(token).toBase58();
        if (!allowedTokens.includes(tokenPubkey)) {
            throw new Error(`${tokenType} token ${token} not allowed. Must be one of: ${allowedTokens.join(', ')}`);
        }
        return tokenPubkey;
    }
    catch (error) {
        throw new Error(`Invalid Solana token address for ${tokenType}: ${token}`);
    }
}
function toAtomicAmount(amount, decimals = 9) {
    // Convert decimal string to atomic units
    const [whole, fraction = ''] = amount.split('.');
    const paddedFraction = fraction.padEnd(decimals, '0');
    const atomicAmount = `${whole}${paddedFraction}`;
    // Remove leading zeros
    return atomicAmount.replace(/^0+/, '') || '0';
}
(async () => {
    try {
        const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(pkpToolRegistryContractAddress);
        const isDelegatee = await (0, aw_tool_1.checkLitAuthAddressIsDelegatee)(pkpToolRegistryContract, pkpTokenId);
        if (!isDelegatee) {
            throw new Error(`Session signer ${LitAuth.authSigAddress} is not a delegatee for PKP ${pkpTokenId}`);
        }
        const policyParameters = await (0, aw_tool_1.getPolicyParameters)(pkpToolRegistryContract, pkpTokenId, parentToolIpfsCid, delegateeAddress, ['maxAmount', 'allowedTokens']);
        let maxAmount = BigInt(0);
        let allowedTokens = [];
        console.log(`Retrieved policy parameters: ${JSON.stringify(policyParameters)}`);
        const decoder = new TextDecoder();
        for (const parameter of policyParameters) {
            if (parameter.value === undefined) {
                console.log(`Parameter ${parameter.name} has undefined value`);
                continue;
            }
            try {
                const bytes = hexToBytes(parameter.value);
                const value = cleanDecodedString(decoder.decode(bytes));
                console.log(`Decoded ${parameter.name}: ${value}`);
                switch (parameter.name) {
                    case 'maxAmount':
                        maxAmount = BigInt(value);
                        console.log(`Formatted maxAmount: ${maxAmount.toString()}`);
                        break;
                    case 'allowedTokens':
                        try {
                            allowedTokens = JSON.parse(value);
                            console.log(`Parsed allowedTokens: ${JSON.stringify(allowedTokens)}`);
                            allowedTokens = allowedTokens.map((addr) => {
                                try {
                                    return new web3_js_1.PublicKey(addr).toBase58();
                                }
                                catch (error) {
                                    throw new Error(`Invalid token address in policy: ${addr}`);
                                }
                            });
                            console.log(`Normalized allowedTokens: ${allowedTokens.join(', ')}`);
                        }
                        catch (error) {
                            throw new Error(`Invalid allowedTokens format: ${error instanceof Error ? error.message : String(error)}`);
                        }
                        break;
                }
            }
            catch (error) {
                throw new Error(`Failed to decode parameter ${parameter.name}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        const atomicAmount = toAtomicAmount(toolParameters.amountIn);
        console.log(`Converting amount ${toolParameters.amountIn} to atomic units: ${atomicAmount}`);
        const amountBigInt = BigInt(atomicAmount);
        if (maxAmount !== BigInt(0)) {
            console.log(`Checking if amount ${amountBigInt.toString()} exceeds maxAmount ${maxAmount.toString()}...`);
            if (amountBigInt > maxAmount) {
                throw new Error(`Amount ${toolParameters.amountIn} exceeds the maximum amount ${maxAmount.toString()}`);
            }
        }
        if (allowedTokens.length > 0) {
            console.log('Validating input and output tokens against allowed list...');
            validateToken(toolParameters.tokenIn, allowedTokens, 'input');
            validateToken(toolParameters.tokenOut, allowedTokens, 'output');
        }
        console.log('Policy parameters validated');
    }
    catch (error) {
        throw new Error(`Policy validation failed: ${error instanceof Error ? error.message : String(error)}`);
    }
})();
