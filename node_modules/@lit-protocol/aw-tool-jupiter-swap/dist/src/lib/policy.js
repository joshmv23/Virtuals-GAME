"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JupiterSwapPolicy = void 0;
const zod_1 = require("zod");
const web3_js_1 = require("@solana/web3.js");
const ethers_1 = require("ethers");
/**
 * Schema for validating a JupiterSwap policy.
 * Ensures the policy has the correct structure and valid values.
 */
const policySchema = zod_1.z.object({
    /** The type of policy, must be `JupiterSwap`. */
    type: zod_1.z.literal('JupiterSwap'),
    /** The version of the policy. */
    version: zod_1.z.string(),
    /** The maximum amount of token that can be sent. */
    maxAmount: zod_1.z.string().refine((val) => {
        try {
            const bn = ethers_1.ethers.BigNumber.from(val);
            return !bn.isNegative(); // Ensure the amount is non-negative
        }
        catch {
            return false; // Invalid format
        }
    }, { message: 'Invalid amount format. Must be a non-negative integer.' }),
    /** The swap can only be performed between these tokens. */
    allowedTokens: zod_1.z.array(zod_1.z.string().refine((val) => {
        try {
            new web3_js_1.PublicKey(val);
            return true;
        }
        catch {
            return false;
        }
    }, "Invalid Solana token address"))
});
/**
 * Encodes a JupiterSwap policy into a format suitable for on-chain storage.
 * @param policy - The JupiterSwap policy to encode.
 * @returns The encoded policy as a hex string.
 * @throws If the policy does not conform to the schema.
 */
function encodePolicy(policy) {
    // Validate the policy against the schema
    policySchema.parse(policy);
    // Convert the allowedTokens array to a JSON string
    const allowedTokensJson = JSON.stringify(policy.allowedTokens);
    // Encode the policy using ABI encoding for Ethereum compatibility
    return ethers_1.ethers.utils.defaultAbiCoder.encode(['tuple(uint256 maxAmount, string allowedTokens)'], [{
            maxAmount: policy.maxAmount,
            allowedTokens: allowedTokensJson
        }]);
}
/**
 * Decodes a JupiterSwap policy from its on-chain encoded format.
 * @param encodedPolicy - The encoded policy as a hex string.
 * @returns The decoded JupiterSwap policy.
 * @throws If the encoded policy is invalid or does not conform to the schema.
 */
function decodePolicy(encodedPolicy) {
    // Decode the ABI-encoded string
    const decoded = ethers_1.ethers.utils.defaultAbiCoder.decode(['tuple(uint256 maxAmount, string allowedTokens)'], encodedPolicy)[0];
    // Parse the JSON string back to an array
    const allowedTokens = JSON.parse(decoded.allowedTokens);
    const policy = {
        type: 'JupiterSwap',
        version: '1.0.0',
        maxAmount: decoded.maxAmount.toString(),
        allowedTokens: allowedTokens.map((addr) => new web3_js_1.PublicKey(addr).toBase58())
    };
    return policySchema.parse(policy);
}
/**
 * Utility object for working with JupiterSwap policies.
 * Includes the schema, encoding, and decoding functions.
 */
exports.JupiterSwapPolicy = {
    /** The type of the policy. */
    type: {},
    /** The version of the policy. */
    version: '1.0.0',
    /** The schema for validating JupiterSwap policies. */
    schema: policySchema,
    /** Encodes a JupiterSwap policy into a format suitable for on-chain storage. */
    encode: encodePolicy,
    /** Decodes a JupiterSwap policy from its on-chain encoded format. */
    decode: decodePolicy,
};
