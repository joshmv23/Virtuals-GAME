"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleAddRpc = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const core_1 = require("../../../core");
const promptChainName = async () => {
    const { chainName } = await (0, prompts_1.default)({
        type: 'text',
        name: 'chainName',
        message: 'Enter the chain name:',
    });
    if (!chainName) {
        throw new core_1.LawCliError(core_1.AddRpcErrors.ADD_RPC_CANCELLED, 'Chain name is required. Operation cancelled.');
    }
    return chainName;
};
const promptChainInfo = async () => {
    const chainInfo = await (0, prompts_1.default)([
        {
            type: 'number',
            name: 'chainId',
            message: 'Enter the chain ID:',
            validate: (value) => value > 0 || 'Chain ID must be greater than 0',
        },
        {
            type: 'text',
            name: 'symbol',
            message: 'Enter the chain symbol:',
            validate: (value) => !!value || 'Symbol is required',
        },
        {
            type: 'number',
            name: 'decimals',
            message: 'Enter the number of decimals:',
            initial: 18,
            validate: (value) => value >= 0 || 'Decimals must be 0 or greater',
        },
        {
            type: 'text',
            name: 'rpcUrl',
            message: 'Enter the RPC URL:',
            validate: (value) => !!value || 'RPC URL is required',
        },
        {
            type: 'text',
            name: 'blockExplorerUrl',
            message: 'Enter the block explorer URL:',
            validate: (value) => !!value || 'Block explorer URL is required',
        },
    ]);
    if (!chainInfo.chainId ||
        !chainInfo.symbol ||
        !chainInfo.rpcUrl ||
        !chainInfo.blockExplorerUrl) {
        throw new core_1.LawCliError(core_1.AddRpcErrors.ADD_RPC_CANCELLED, 'All chain information is required. Operation cancelled.');
    }
    return {
        ...chainInfo,
        vmType: 'EVM',
    };
};
const formatChainKey = (name) => name.toLowerCase().replace(/\s+(.)/g, (_, c) => c.toUpperCase());
const handleAddRpc = async (localStorage) => {
    try {
        // Get existing chains
        const existingRpcsString = localStorage.getItem(core_1.StorageKeys.RPCS);
        const existingRpcs = existingRpcsString
            ? JSON.parse(existingRpcsString)
            : {};
        // Get and validate chain name
        const chainName = await promptChainName();
        const chainKey = formatChainKey(chainName);
        // Check if chain name already exists
        const chainExists = Object.values(existingRpcs).some((chain) => chain.name.toLowerCase() === chainName.toLowerCase());
        if (chainExists) {
            throw new core_1.LawCliError(core_1.AddRpcErrors.CHAIN_NAME_EXISTS, `Chain with name "${chainName}" already exists.`);
        }
        // Get chain info
        const chainInfo = await promptChainInfo();
        // Add new chain to existing chains
        const newChain = {
            name: chainName,
            chainId: chainInfo.chainId,
            symbol: chainInfo.symbol,
            decimals: chainInfo.decimals,
            rpcUrls: [chainInfo.rpcUrl],
            blockExplorerUrls: [chainInfo.blockExplorerUrl],
            vmType: 'EVM',
        };
        existingRpcs[chainKey] = newChain;
        // Save updated chains
        localStorage.setItem(core_1.StorageKeys.RPCS, JSON.stringify(existingRpcs));
        core_1.logger.success(`Added new chain: ${chainName}`);
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.AddRpcErrors.CHAIN_NAME_EXISTS) {
                core_1.logger.error(error.message);
                return;
            }
            if (error.type === core_1.AddRpcErrors.ADD_RPC_CANCELLED) {
                core_1.logger.error(error.message);
                return;
            }
        }
        throw error;
    }
};
exports.handleAddRpc = handleAddRpc;
