"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getToolParams = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const core_1 = require("../../core");
const get_chain_details_1 = require("./get-chain-details");
/**
 * Prompts the user to input parameters for a tool.
 */
const getToolParams = async (localStorage, tool, pkpEthAddress, options) => {
    const params = { ...options?.foundParams };
    const paramsToPrompt = options?.missingParams
        ? Object.entries(tool.parameters.descriptions).filter(([paramName]) => options.missingParams?.includes(paramName))
        : Object.entries(tool.parameters.descriptions);
    // First check if we need both chain parameters
    const needsChainId = paramsToPrompt.some(([paramName]) => paramName === 'chainId');
    const needsRpcUrl = paramsToPrompt.some(([paramName]) => paramName === 'rpcUrl');
    // If we need either chain parameter, handle them together
    if (needsChainId || needsRpcUrl) {
        const chainParams = await (0, get_chain_details_1.promptSelectChain)(localStorage, {
            needsChainId,
            needsRpcUrl,
        });
        if (chainParams.chainId)
            params.chainId = chainParams.chainId;
        if (chainParams.rpcUrl)
            params.rpcUrl = chainParams.rpcUrl;
        // Filter out the chain parameters as we've handled them
        paramsToPrompt.splice(0, paramsToPrompt.length, ...paramsToPrompt.filter(([paramName]) => paramName !== 'chainId' && paramName !== 'rpcUrl'));
    }
    // Handle remaining parameters
    for (const [paramName, description] of paramsToPrompt) {
        if (paramName === 'pkpEthAddress') {
            params.pkpEthAddress = pkpEthAddress;
            continue;
        }
        const { value } = await (0, prompts_1.default)({
            type: 'text',
            name: 'value',
            message: `Enter ${paramName} (${description}):`,
        });
        if (value === undefined) {
            throw new core_1.LawCliError(core_1.DelegateeErrors.TOOL_PARAMS_CANCELLED, 'Parameter input was cancelled');
        }
        params[paramName] = value;
    }
    const validationResult = tool.parameters.validate(params);
    if (validationResult !== true) {
        const errors = validationResult
            .map(({ param, error }) => `${param}: ${error}`)
            .join('\n');
        throw new core_1.LawCliError(core_1.DelegateeErrors.TOOL_PARAMS_INVALID, `Invalid parameters:\n${errors}`);
    }
    return params;
};
exports.getToolParams = getToolParams;
