"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleUseEoaForAdmin = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const ethers_1 = require("ethers");
const core_1 = require("../../../../core");
const menu_1 = require("./menu");
const admin_1 = require("../../admin");
const promptSelectAdmin = async (localStorage) => {
    const admins = getStoredAdmins(localStorage);
    const addresses = Object.keys(admins);
    if (addresses.length === 0) {
        return null;
    }
    const choices = [
        {
            title: 'Use new private key',
            value: 'new',
        },
        ...addresses.map((addr) => ({
            title: addr,
            value: addr,
        })),
    ];
    const { selection } = await (0, prompts_1.default)({
        type: 'select',
        name: 'selection',
        message: 'Select an admin wallet or add a new one:',
        choices,
    });
    if (!selection) {
        throw new core_1.LawCliError(core_1.AdminErrors.ADMIN_SELECTION_CANCELLED, 'Admin selection cancelled.');
    }
    if (selection === 'new') {
        return null;
    }
    return {
        address: selection,
        privateKey: admins[selection].privateKey,
    };
};
const promptPrivateKey = async () => {
    const { privateKey } = await (0, prompts_1.default)({
        type: 'password',
        name: 'privateKey',
        message: 'Enter your private key:',
        validate: (value) => {
            // Basic validation for private key format (0x followed by 64 hex characters)
            const isValidFormat = /^0x[0-9a-fA-F]{64}$/.test(value);
            return isValidFormat
                ? true
                : 'Please enter a valid private key (0x followed by 64 hex characters)';
        },
    });
    if (!privateKey) {
        throw new core_1.LawCliError(core_1.AdminErrors.ADMIN_MISSING_PRIVATE_KEY, 'No private key provided. Operation cancelled.');
    }
    return privateKey;
};
const getStoredAdmins = (localStorage) => {
    const storedData = localStorage.getItem(core_1.StorageKeys.ADMIN_STORAGE);
    return storedData ? JSON.parse(storedData) : {};
};
const saveAdmin = (localStorage, address, privateKey) => {
    const admins = getStoredAdmins(localStorage);
    admins[address] = {
        privateKey,
    };
    localStorage.setItem(core_1.StorageKeys.ADMIN_STORAGE, JSON.stringify(admins));
};
const handleUseEoaForAdmin = async (localStorage) => {
    try {
        // First check if we have any stored admins
        const existingAdmin = await promptSelectAdmin(localStorage);
        let privateKey;
        let address;
        if (existingAdmin) {
            privateKey = existingAdmin.privateKey;
            address = existingAdmin.address;
        }
        else {
            privateKey = await promptPrivateKey();
            // Create wallet to get address
            const wallet = new ethers_1.ethers.Wallet(privateKey);
            address = wallet.address;
            // Save new admin
            saveAdmin(localStorage, address, privateKey);
        }
        // Set the current active admin
        localStorage.setItem(core_1.StorageKeys.ADMIN_ACTIVE_ADDRESS, address);
        localStorage.setItem(core_1.StorageKeys.ADMIN_SIGNER_TYPE, menu_1.AdminSignerType.Eoa);
        const litNetwork = await (0, core_1.getLitNetwork)(localStorage);
        const awAdmin = await admin_1.Admin.create(litNetwork, privateKey);
        core_1.logger.success(`EOA signer configured successfully with address: ${address}`);
        return awAdmin;
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.AdminErrors.ADMIN_MISSING_PRIVATE_KEY ||
                error.type === core_1.AdminErrors.FAILED_TO_INITIALIZE_ADMIN ||
                error.type === core_1.AdminErrors.ADMIN_SELECTION_CANCELLED) {
                core_1.logger.error(error.message);
                return await (0, exports.handleUseEoaForAdmin)(localStorage);
            }
        }
        throw error;
    }
};
exports.handleUseEoaForAdmin = handleUseEoaForAdmin;
