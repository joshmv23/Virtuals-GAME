"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleGetToolPolicy = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const core_1 = require("../../../core");
const promptSelectToolWithPolicy = async (toolsWithPolicies) => {
    const choices = toolsWithPolicies.map((tool) => ({
        title: tool.name,
        description: `${Object.keys(tool.delegateePolicies).length} policies`,
        value: tool,
    }));
    const { tool } = await (0, prompts_1.default)({
        type: 'select',
        name: 'tool',
        message: 'Select a tool to view policy:',
        choices,
    });
    if (!tool) {
        throw new core_1.LawCliError(core_1.GetToolPolicyErrors.GET_TOOL_POLICY_CANCELLED, 'Tool policy viewing cancelled.');
    }
    return tool;
};
const promptSelectDelegatee = async (delegateePolicies) => {
    const { delegatee } = await (0, prompts_1.default)({
        type: 'select',
        name: 'delegatee',
        message: 'Select a Delegatee to view policy for:',
        choices: Object.entries(delegateePolicies).map(([address, policy]) => ({
            title: address,
            description: `Policy: ${policy.policyIpfsCid}`,
            value: address,
        })),
    });
    if (!delegatee) {
        throw new core_1.LawCliError(core_1.GetToolPolicyErrors.GET_TOOL_POLICY_CANCELLED, 'Delegatee selection cancelled.');
    }
    return delegatee;
};
const displayToolPolicy = async (admin, pkp, tool, delegatee) => {
    const policy = tool.delegateePolicies[delegatee];
    core_1.logger.info(`Policy details for tool ${tool.name}:`);
    core_1.logger.log(`  Tool IPFS CID: ${tool.ipfsCid}`);
    core_1.logger.log(`    Status: ${tool.toolEnabled ? 'Enabled' : 'Disabled'}`);
    core_1.logger.log(`  Delegatee: ${delegatee}`);
    core_1.logger.log(`  Policy IPFS CID: ${policy.policyIpfsCid}`);
    core_1.logger.log(`    Status: ${policy.policyEnabled ? 'Enabled' : 'Disabled'}`);
    // Get and display policy parameters if they exist
    const policyParameters = await admin.awAdmin.getAllToolPolicyParametersForDelegatee(pkp.info.tokenId, tool.ipfsCid, delegatee);
    if (policyParameters && Object.keys(policyParameters).length > 0) {
        core_1.logger.log('  Parameters:');
        Object.entries(policyParameters).forEach(([key, value]) => {
            core_1.logger.info(`    ${key}: ${value}`);
        });
    }
    else {
        core_1.logger.log('  No policy parameters set');
    }
};
const handleGetToolPolicy = async (admin, pkp) => {
    try {
        const registeredTools = await admin.awAdmin.getRegisteredToolsAndDelegateesForPkp(pkp.info.tokenId);
        if (registeredTools === null ||
            Object.keys(registeredTools.toolsWithPolicies).length === 0) {
            throw new core_1.LawCliError(core_1.GetToolPolicyErrors.NO_TOOLS_WITH_POLICIES, 'No tools with policies found.');
        }
        const selectedTool = await promptSelectToolWithPolicy(Object.values(registeredTools.toolsWithPolicies));
        const selectedDelegatee = await promptSelectDelegatee(selectedTool.delegateePolicies);
        await displayToolPolicy(admin, pkp, selectedTool, selectedDelegatee);
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.GetToolPolicyErrors.GET_TOOL_POLICY_CANCELLED ||
                error.type === core_1.GetToolPolicyErrors.NO_TOOLS_WITH_POLICIES) {
                core_1.logger.error(error.message);
                return;
            }
        }
        throw error;
    }
};
exports.handleGetToolPolicy = handleGetToolPolicy;
