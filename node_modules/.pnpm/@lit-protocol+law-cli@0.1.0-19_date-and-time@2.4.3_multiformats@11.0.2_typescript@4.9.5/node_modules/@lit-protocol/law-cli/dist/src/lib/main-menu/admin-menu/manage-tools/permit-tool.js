"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePermitTool = exports.promptSelectToolToPermit = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const agent_wallet_1 = require("@lit-protocol/agent-wallet");
const core_1 = require("../../../core");
/**
 * Prompts the user to select a tool to permit, filtering out already permitted tools.
 * This function retrieves the list of available tools for the specified Lit network,
 * filters out tools that are already permitted, and prompts the user to select a tool.
 *
 * @param litNetwork - The Lit network for which to retrieve available tools.
 * @param alreadyPermittedTools - An object containing tools that are already permitted.
 * @returns The selected tool to permit.
 * @throws AwCliError - If no unpermitted tools are found or the user cancels the selection.
 */
const promptSelectToolToPermit = async (litNetwork, alreadyPermittedTools) => {
    // Retrieve the list of available tools for the specified Lit network.
    const availableTools = (0, agent_wallet_1.listToolsByNetwork)(litNetwork);
    // Create a set of IPFS CIDs for already permitted tools for efficient lookup.
    const permittedCids = new Set([
        ...(alreadyPermittedTools
            ? Object.keys(alreadyPermittedTools.toolsWithPolicies)
            : []),
        ...(alreadyPermittedTools
            ? Object.keys(alreadyPermittedTools.toolsWithoutPolicies)
            : []),
    ]);
    // Filter out tools that are already permitted.
    const unpermittedTools = availableTools.filter((tool) => !permittedCids.has(tool.ipfsCid));
    // If no unpermitted tools are found, throw an error.
    if (unpermittedTools.length === 0) {
        throw new core_1.LawCliError(core_1.PermitToolErrors.NO_UNPERMITTED_TOOLS, 'No unpermitted tools found.');
    }
    // Prompt the user to select a tool to permit.
    const { tool } = await (0, prompts_1.default)({
        type: 'select',
        name: 'tool',
        message: 'Select a tool to permit:',
        choices: unpermittedTools.map((tool) => ({
            title: tool.name,
            description: tool.description,
            value: tool,
        })),
    });
    // If the user cancels the selection, throw an error.
    if (!tool) {
        throw new core_1.LawCliError(core_1.PermitToolErrors.PERMIT_TOOL_CANCELLED, 'Tool permitting cancelled.');
    }
    // Return the selected tool.
    return tool;
};
exports.promptSelectToolToPermit = promptSelectToolToPermit;
const promptEnableTool = async () => {
    const { enableTool } = await (0, prompts_1.default)({
        type: 'confirm',
        name: 'enableTool',
        message: 'Enable tool after permitting?',
        initial: true,
    });
    if (enableTool === undefined) {
        throw new core_1.LawCliError(core_1.PermitToolErrors.ENABLE_TOOL_CANCELLED, 'Enable tool selection cancelled.');
    }
    return enableTool;
};
const handlePermitTool = async (admin, pkp) => {
    try {
        const registeredTools = await admin.awAdmin.getRegisteredToolsAndDelegateesForPkp(pkp.info.tokenId);
        const selectedTool = await (0, exports.promptSelectToolToPermit)(admin.awAdmin.litNetwork, registeredTools);
        const shouldEnableTool = await promptEnableTool();
        await admin.awAdmin.registerTool(pkp.info.tokenId, selectedTool.ipfsCid, {
            enableTools: shouldEnableTool,
        });
        core_1.logger.success(`Tool ${selectedTool.name} registered successfully${shouldEnableTool ? ' and enabled' : ''}.`);
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.PermitToolErrors.PERMIT_TOOL_CANCELLED ||
                error.type === core_1.PermitToolErrors.ENABLE_TOOL_CANCELLED) {
                core_1.logger.error(error.message);
                return;
            }
        }
        throw error;
    }
};
exports.handlePermitTool = handlePermitTool;
