"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSetPolicy = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const core_1 = require("../../../core");
const promptSelectToolForPolicy = async (registeredTools) => {
    // Combine tools with and without policies into a single list of choices
    const choices = [
        // TODO You have to remove a policy before being able to set a new one
        // this should do that for the user when selected
        // ...Object.values(registeredTools.toolsWithPolicies).map((tool) => ({
        //   title: tool.name,
        //   description: 'Update existing policy',
        //   value: tool,
        // })),
        ...Object.values(registeredTools.toolsWithoutPolicies).map((tool) => ({
            title: tool.name,
            //   description: 'Set new policy',
            value: tool,
        })),
    ];
    if (choices.length === 0) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.NO_TOOLS_FOUND, 'No tools found to set policy for.');
    }
    const { tool } = await (0, prompts_1.default)({
        type: 'select',
        name: 'tool',
        message: 'Select a tool to set policy for:',
        choices,
    });
    if (!tool) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'Tool selection cancelled.');
    }
    return tool;
};
const promptSelectToolDelegateeForPolicy = async (admin, pkp, selectedTool) => {
    // Get all PKP delegatees
    const pkpDelegatees = await admin.awAdmin.getDelegatees(pkp.info.tokenId);
    if (pkpDelegatees.length === 0) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'No Delegatees found.');
    }
    // Filter delegatees to only those that have the tool permitted but no policy set
    const delegateesWithoutPolicy = [];
    for (const delegatee of pkpDelegatees) {
        const delegateePermittedTools = await admin.awAdmin.getPermittedToolsForDelegatee(pkp.info.tokenId, delegatee);
        if (delegateePermittedTools.some((tool) => tool.toolIpfsCid === selectedTool.ipfsCid) &&
            !('delegateePolicies' in selectedTool &&
                delegatee in selectedTool.delegateePolicies)) {
            delegateesWithoutPolicy.push(delegatee);
        }
    }
    if (delegateesWithoutPolicy.length === 0) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'No Delegatees found without existing policy for this tool.');
    }
    const choices = delegateesWithoutPolicy.map((delegatee) => ({
        title: delegatee,
        value: delegatee,
    }));
    const { delegatee } = await (0, prompts_1.default)({
        type: 'select',
        name: 'delegatee',
        message: 'Select a Delegatee to set policy for:',
        choices,
    });
    if (!delegatee) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'Delegatee selection cancelled.');
    }
    return delegatee;
};
const promptPolicyDetails = async () => {
    const { policyIpfsCid } = await (0, prompts_1.default)({
        type: 'text',
        name: 'policyIpfsCid',
        message: 'Enter the IPFS CID of the policy:',
        validate: (value) => !!value || 'Policy IPFS CID is required',
    });
    if (!policyIpfsCid) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'No policy IPFS CID provided. Operation cancelled.');
    }
    const { enablePolicy } = await (0, prompts_1.default)({
        type: 'confirm',
        name: 'enablePolicy',
        message: 'Enable policy after setting?',
        initial: true,
    });
    if (enablePolicy === undefined) {
        throw new core_1.LawCliError(core_1.SetPolicyErrors.SET_POLICY_CANCELLED, 'Enable policy selection cancelled.');
    }
    return { policyIpfsCid, enablePolicy };
};
const handleSetPolicy = async (admin, pkp) => {
    try {
        const registeredTools = await admin.awAdmin.getRegisteredToolsAndDelegateesForPkp(pkp.info.tokenId);
        if (Object.keys(registeredTools.toolsWithPolicies).length === 0 &&
            Object.keys(registeredTools.toolsWithoutPolicies).length === 0) {
            throw new core_1.LawCliError(core_1.SetPolicyErrors.NO_TOOLS_FOUND, 'No tools are currently permitted.');
        }
        // Select tool for setting or updating policy
        const selectedTool = await promptSelectToolForPolicy(registeredTools);
        const selectedDelegatee = await promptSelectToolDelegateeForPolicy(admin, pkp, selectedTool);
        const { policyIpfsCid, enablePolicy } = await promptPolicyDetails();
        await admin.awAdmin.setToolPolicyForDelegatee(pkp.info.tokenId, selectedTool.ipfsCid, selectedDelegatee, policyIpfsCid, enablePolicy);
        core_1.logger.success(`Policy set successfully for tool ${selectedTool.name}${enablePolicy ? ' and enabled' : ''}.`);
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.SetPolicyErrors.SET_POLICY_CANCELLED ||
                error.type === core_1.SetPolicyErrors.NO_TOOLS_FOUND) {
                core_1.logger.error(error.message);
                return;
            }
        }
        throw error;
    }
};
exports.handleSetPolicy = handleSetPolicy;
