"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleEditRpc = void 0;
const tslib_1 = require("tslib");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const core_1 = require("../../../core");
const promptSelectChain = async (existingRpcs) => {
    const { chainKey } = await (0, prompts_1.default)({
        type: 'autocomplete',
        name: 'chainKey',
        message: 'Select a chain to edit (start typing to filter):',
        choices: Object.entries(existingRpcs)
            .map(([key, chain]) => ({
            title: (chain.name || '')
                .trim()
                .replace(/\s+/g, ' '),
            value: key,
        }))
            .sort((a, b) => a.title.localeCompare(b.title)),
        suggest: async (input, choices) => {
            const inputLower = input.toLowerCase();
            return choices.filter((choice) => choice.title.toLowerCase().includes(inputLower));
        },
    });
    if (!chainKey) {
        throw new core_1.LawCliError(core_1.EditRpcErrors.EDIT_RPC_CANCELLED, 'No chain selected. Operation cancelled.');
    }
    return chainKey;
};
const promptEditChainInfo = async (chain) => {
    const typedChain = chain;
    const chainInfo = await (0, prompts_1.default)([
        {
            type: 'text',
            name: 'name',
            message: 'Enter the chain name:',
            initial: typedChain.name,
            validate: (value) => !!value || 'Name is required',
        },
        {
            type: 'text',
            name: 'chainId',
            message: 'Enter the chain ID:',
            initial: String(typedChain.chainId),
            validate: (value) => {
                const intValue = Math.floor(Number(value));
                if (Number.isNaN(intValue))
                    return 'Chain ID must be a number';
                return intValue > 0 ? true : 'Chain ID must be greater than 0';
            },
        },
        {
            type: 'text',
            name: 'symbol',
            message: 'Enter the chain symbol:',
            initial: typedChain.symbol,
            validate: (value) => !!value || 'Symbol is required',
        },
        {
            type: 'number',
            name: 'decimals',
            message: 'Enter the number of decimals:',
            initial: typedChain.decimals,
            validate: (value) => value >= 0 || 'Decimals must be 0 or greater',
        },
        {
            type: 'text',
            name: 'rpcUrl',
            message: 'Enter the RPC URL:',
            initial: typedChain.rpcUrls[0] || '',
            validate: (value) => !!value || 'RPC URL is required',
        },
        {
            type: 'text',
            name: 'blockExplorerUrl',
            message: 'Enter the block explorer URL:',
            initial: typedChain.blockExplorerUrls[0] || '',
            validate: (value) => !!value || 'Block explorer URL is required',
        },
    ]);
    if (!chainInfo.name ||
        !chainInfo.chainId ||
        !chainInfo.symbol ||
        !chainInfo.rpcUrl ||
        !chainInfo.blockExplorerUrl) {
        throw new core_1.LawCliError(core_1.EditRpcErrors.EDIT_RPC_CANCELLED, 'All chain information is required. Operation cancelled.');
    }
    return {
        ...chainInfo,
        rpcUrls: [chainInfo.rpcUrl],
        blockExplorerUrls: [chainInfo.blockExplorerUrl],
        vmType: 'EVM',
    };
};
const handleEditRpc = async (localStorage) => {
    try {
        const existingRpcsString = localStorage.getItem(core_1.StorageKeys.RPCS);
        const existingRpcs = existingRpcsString
            ? JSON.parse(existingRpcsString)
            : {};
        if (Object.keys(existingRpcs).length === 0) {
            throw new core_1.LawCliError(core_1.EditRpcErrors.NO_RPCS_FOUND, 'No RPCs found to edit.');
        }
        // Select chain to edit
        const chainKey = await promptSelectChain(existingRpcs);
        const selectedChain = existingRpcs[chainKey];
        // Edit chain info
        const updatedChain = await promptEditChainInfo(selectedChain);
        existingRpcs[chainKey] = updatedChain;
        // Save updated chains
        localStorage.setItem(core_1.StorageKeys.RPCS, JSON.stringify(existingRpcs));
        core_1.logger.success(`Updated chain: ${updatedChain.name}`);
    }
    catch (error) {
        if (error instanceof core_1.LawCliError) {
            if (error.type === core_1.EditRpcErrors.EDIT_RPC_CANCELLED) {
                core_1.logger.error(error.message);
                return;
            }
            if (error.type === core_1.EditRpcErrors.NO_RPCS_FOUND) {
                core_1.logger.error(error.message);
                return;
            }
        }
        throw error;
    }
};
exports.handleEditRpc = handleEditRpc;
