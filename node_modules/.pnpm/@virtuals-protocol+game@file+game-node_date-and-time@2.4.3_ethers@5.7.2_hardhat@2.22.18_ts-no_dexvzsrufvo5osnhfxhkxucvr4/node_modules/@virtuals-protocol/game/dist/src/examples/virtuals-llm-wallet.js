"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const game_1 = require("@virtuals-protocol/game");
const lit_agent_wallet_1 = __importDefault(require("../lit-agent-wallet"));
// Initialize the Lit Agent Wallet
const agentWallet = new lit_agent_wallet_1.default();
// Define token-related functions with detailed descriptions
const checkBalanceFunction = new game_1.GameFunction({
    name: "check_balance",
    description: "Check token balance for a specific token address. Returns the balance in token units with proper decimals.",
    args: [
        { name: "token", description: "Token contract address to check balance for" },
        { name: "address", description: "Address to check balance for" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!args.token || !args.address) {
                throw new Error("Missing required arguments");
            }
            logger(`Checking balance of ${args.token} for address ${args.address}`);
            const balance = yield agentWallet.checkBalance(args.token, args.address);
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Balance: ${balance}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to check balance: ${error.message}`);
        }
    }),
});
const transferTokensFunction = new game_1.GameFunction({
    name: "transfer_tokens",
    description: "Transfer tokens with policy enforcement. Ensures transfers comply with daily limits and token allowances.",
    args: [
        { name: "token", description: "Token contract address to transfer" },
        { name: "to", description: "Recipient address" },
        { name: "amount", description: "Amount to transfer in token units" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!args.token || !args.to || !args.amount) {
                throw new Error("Missing required arguments");
            }
            logger(`Initiating policy-compliant transfer of ${args.amount} ${args.token} to ${args.to}`);
            const result = yield agentWallet.executeTransfer(args.token, args.to, args.amount);
            logger('Transfer executed successfully');
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Transfer completed: ${args.amount} ${args.token} -> ${args.to}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to transfer tokens: ${error.message}`);
        }
    }),
});
const swapTokensFunction = new game_1.GameFunction({
    name: "swap_tokens",
    description: "Execute token swaps via Uniswap with policy enforcement. Handles price impact checks and slippage protection.",
    args: [
        { name: "tokenIn", description: "Token address to swap from" },
        { name: "tokenOut", description: "Token address to swap to" },
        { name: "amountIn", description: "Amount of input token to swap" },
        { name: "maxSlippage", description: "Maximum allowed slippage in percentage", optional: true },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!args.tokenIn || !args.tokenOut || !args.amountIn) {
                throw new Error("Missing required arguments");
            }
            logger(`Initiating policy-compliant swap of ${args.amountIn} ${args.tokenIn} to ${args.tokenOut}`);
            const result = yield agentWallet.executeSwap(args.tokenIn, args.tokenOut, args.amountIn);
            logger('Swap executed successfully');
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Swap completed: ${args.amountIn} ${args.tokenIn} -> ${args.tokenOut}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to swap tokens: ${error.message}`);
        }
    }),
});
// Create specialized workers for different token operations
const tokenQueryWorker = new game_1.GameWorker({
    id: "token_query_worker",
    name: "Token Information Worker",
    description: "Specialized worker for querying token information and balances. Handles all read-only token operations.",
    functions: [checkBalanceFunction],
});
const tokenTransferWorker = new game_1.GameWorker({
    id: "token_transfer_worker",
    name: "Token Transfer Worker",
    description: "Specialized worker for executing token transfers with policy enforcement. Ensures all transfers comply with security policies.",
    functions: [transferTokensFunction],
});
const tokenSwapWorker = new game_1.GameWorker({
    id: "token_swap_worker",
    name: "Token Swap Worker",
    description: "Specialized worker for executing token swaps via Uniswap. Handles price checks, slippage protection, and policy compliance.",
    functions: [swapTokensFunction],
});
// Create the high-level agent that coordinates the workers
const agent = new game_1.GameAgent(process.env.VIRTUALS_API_KEY || "", {
    name: "Virtuals Token Operations Agent",
    goal: "Safely manage token operations while ensuring compliance with security policies and optimal execution",
    description: `A sophisticated agent that manages token operations on the Chronicle Yellowstone network.
        - Enforces security policies for all token operations
        - Optimizes swap routes and handles slippage protection
        - Maintains detailed operation logs
        - Ensures all operations comply with daily limits and token allowances
        - Coordinates between different specialized workers for optimal execution`,
    workers: [tokenQueryWorker, tokenTransferWorker, tokenSwapWorker],
});
// Example usage with natural language tasks
function runExample() {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        try {
            // Initialize everything
            yield agentWallet.init();
            yield agent.init();
            // Set up custom logger
            agent.setLogger((msg) => {
                console.log(`-----[${agent.name}]-----`);
                console.log(msg);
                console.log("\n");
            });
            // Example tasks that demonstrate natural language processing
            const tasks = [
                `Check the testLIT token balance for ${yield ((_a = agentWallet.getWallet()) === null || _a === void 0 ? void 0 : _a.getAddress())}`,
                `Check the LIT token balance at 0x81d8f0e945E3Bdc735dA3E19C4Df77a8B91046Cd`,
                `Transfer 0.1 LIT tokens from 0x81d8f0e945E3Bdc735dA3E19C4Df77a8B91046Cd to ${yield ((_b = agentWallet.getWallet()) === null || _b === void 0 ? void 0 : _b.getAddress())}`
            ];
            for (const task of tasks) {
                console.log(`\nExecuting task: ${task}`);
                yield agent.step();
            }
        }
        catch (error) {
            console.error("Error:", error.message);
        }
    });
}
if (require.main === module) {
    runExample();
}
