"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const pkp_ethers_1 = require("@lit-protocol/pkp-ethers");
const ethers_1 = require("ethers");
const dotenv_1 = __importDefault(require("dotenv"));
const auth_helpers_1 = require("@lit-protocol/auth-helpers");
const constants_1 = require("@lit-protocol/constants");
const typechain_types_1 = require("../typechain-types");
const ERC20_ABI = [
    "function balanceOf(address owner) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function transfer(address to, uint amount) returns (bool)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint amount) returns (bool)"
];
dotenv_1.default.config();
class VirtualsAgentWallet {
    constructor() {
        this.pkpWallet = null;
        this.virtualsPolicyContract = null;
        this.litAgentWalletContract = null;
        this.litNodeClient = new lit_node_client_1.LitNodeClient({
            litNetwork: 'datil-test',
            debug: true,
        });
        this.provider = new ethers_1.ethers.providers.JsonRpcProvider(process.env.RPC_URL);
    }
    // Public getter for pkpWallet
    getWallet() {
        return this.pkpWallet;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            // Connect to Lit nodes
            yield this.litNodeClient.connect();
            if (!process.env.POLICY_ADDRESS || !process.env.LIT_AGENT_WALLET_ADDRESS) {
                throw new Error("Missing contract addresses in environment variables");
            }
            // Initialize contract instances
            this.virtualsPolicyContract = typechain_types_1.VirtualsPolicy__factory.connect(process.env.POLICY_ADDRESS, this.provider);
            this.litAgentWalletContract = typechain_types_1.LitAgentWallet__factory.connect(process.env.LIT_AGENT_WALLET_ADDRESS, this.provider);
        });
    }
    initializePKPWallet(pkpPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.litNodeClient.ready) {
                throw new Error("Lit client not initialized");
            }
            const resourceAbilities = [{
                    resource: new auth_helpers_1.LitActionResource('*'),
                    ability: constants_1.LIT_ABILITY.LitActionExecution
                }];
            const sessionSigs = yield this.litNodeClient.getSessionSigs({
                chain: "ethereum",
                expiration: new Date(Date.now() + 60000 * 60).toISOString(),
                resourceAbilityRequests: resourceAbilities,
                authNeededCallback: (_a) => __awaiter(this, [_a], void 0, function* ({ resourceAbilityRequests, expiration, uri }) {
                    const wallet = new ethers_1.ethers.Wallet(process.env.PRIVATE_KEY || "", this.provider);
                    const toSign = yield (0, auth_helpers_1.createSiweMessageWithRecaps)({
                        uri: 'https://localhost/login',
                        expiration: expiration || new Date(Date.now() + 60000 * 60).toISOString(),
                        resources: resourceAbilityRequests || [],
                        walletAddress: yield wallet.getAddress(),
                        nonce: yield this.litNodeClient.getLatestBlockhash(),
                        litNodeClient: this.litNodeClient,
                    });
                    return yield (0, auth_helpers_1.generateAuthSig)({
                        signer: wallet,
                        toSign,
                    });
                }),
            });
            this.pkpWallet = new pkp_ethers_1.PKPEthersWallet({
                pkpPubKey: pkpPublicKey,
                provider: this.provider,
                litNodeClient: this.litNodeClient,
                authContext: {
                    getSessionSigsProps: {
                        chain: "ethereum",
                        resourceAbilityRequests: resourceAbilities,
                        authNeededCallback: () => __awaiter(this, void 0, void 0, function* () {
                            var _a;
                            return ({
                                sig: "test",
                                derivedVia: "web3.eth.personal.sign",
                                signedMessage: "test",
                                address: (yield ((_a = this.pkpWallet) === null || _a === void 0 ? void 0 : _a.getAddress())) || ""
                            });
                        })
                    }
                }
            });
            yield this.pkpWallet.init();
            // Connect contracts with PKP wallet after initialization
            if (this.litAgentWalletContract && this.pkpWallet) {
                this.litAgentWalletContract = this.litAgentWalletContract.connect(this.pkpWallet);
            }
        });
    }
    // Admin functions
    setupAdmin(adminPrivateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const adminWallet = new ethers_1.ethers.Wallet(adminPrivateKey, this.provider);
            const policyWithSigner = (_a = this.virtualsPolicyContract) === null || _a === void 0 ? void 0 : _a.connect(adminWallet);
            if (!policyWithSigner)
                throw new Error("Policy contract not initialized");
            // Admin functions will be handled through the multisig process
            console.log("Admin setup complete. Use the multisig interface to propose and approve changes.");
        });
    }
    addDelegatee(delegateeAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.virtualsPolicyContract)
                throw new Error("Policy contract not initialized");
            const tx = yield this.virtualsPolicyContract.proposeDelegateeStatus(delegateeAddress, true);
            yield tx.wait();
            console.log(`Delegatee status proposed for ${delegateeAddress}. Waiting for admin approvals.`);
        });
    }
    setToolPolicy(toolName, policy) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.virtualsPolicyContract)
                throw new Error("Policy contract not initialized");
            // Convert tool policy to on-chain parameters
            const toolId = ethers_1.ethers.utils.id(toolName);
            // Propose the policy changes through multisig
            const tx = yield this.virtualsPolicyContract.proposeMaxTransactionAmount(ethers_1.ethers.utils.parseEther(policy.maxAmount));
            yield tx.wait();
            console.log(`Tool policy proposed for ${toolName}. Waiting for admin approvals.`);
        });
    }
    // Execution functions
    executeTransfer(tokenAddress, to, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pkpWallet || !this.litAgentWalletContract) {
                throw new Error("Wallet or contract not initialized");
            }
            const toolId = ethers_1.ethers.utils.id("erc20-transfer");
            const walletWithSigner = this.litAgentWalletContract.connect(this.pkpWallet);
            if (tokenAddress.toLowerCase() === 'eth') {
                const tx = yield walletWithSigner.executeTransaction(to, ethers_1.ethers.utils.parseEther(amount), "0x", toolId);
                return yield tx.wait();
            }
            else {
                const tx = yield walletWithSigner.executeERC20Transfer(tokenAddress, to, ethers_1.ethers.utils.parseEther(amount), toolId);
                return yield tx.wait();
            }
        });
    }
    executeSwap(tokenIn, tokenOut, amountIn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pkpWallet || !this.litAgentWalletContract) {
                throw new Error("Wallet or contract not initialized");
            }
            const toolId = ethers_1.ethers.utils.id("uniswap-swap");
            const walletWithSigner = this.litAgentWalletContract.connect(this.pkpWallet);
            // Implement Uniswap swap logic here
            // This is a placeholder for the actual swap implementation
            throw new Error("Swap functionality not implemented yet");
        });
    }
    // Add this method to the VirtualsAgentWallet class
    checkBalance(tokenAddress, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pkpWallet) {
                throw new Error("Wallet not initialized");
            }
            if (tokenAddress.toLowerCase() === 'eth') {
                const balance = yield this.provider.getBalance(address);
                return ethers_1.ethers.utils.formatEther(balance);
            }
            else {
                const tokenContract = new ethers_1.ethers.Contract(tokenAddress, ERC20_ABI, this.provider);
                const balance = yield tokenContract.balanceOf(address);
                const decimals = yield tokenContract.decimals();
                return ethers_1.ethers.utils.formatUnits(balance, decimals);
            }
        });
    }
}
exports.default = VirtualsAgentWallet;
