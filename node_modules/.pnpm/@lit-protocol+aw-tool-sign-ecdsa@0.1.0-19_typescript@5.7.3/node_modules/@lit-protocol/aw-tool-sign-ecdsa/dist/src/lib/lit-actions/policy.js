"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
(async () => {
    const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(pkpToolRegistryContractAddress);
    const isDelegatee = await (0, aw_tool_1.checkLitAuthAddressIsDelegatee)(pkpToolRegistryContract, pkpTokenId);
    if (!isDelegatee) {
        throw new Error(`Session signer ${ethers.utils.getAddress(LitAuth.authSigAddress)} is not a delegatee for PKP ${pkpTokenId}`);
    }
    // Get allowed prefixes from policy parameters
    const policyParameters = await (0, aw_tool_1.getPolicyParameters)(pkpToolRegistryContract, pkpTokenId, parentToolIpfsCid, delegateeAddress, ['allowedPrefixes']);
    // Extract and parse allowedPrefixes
    const allowedPrefixesParam = policyParameters.find((p) => p.name === 'allowedPrefixes');
    if (!allowedPrefixesParam) {
        throw new Error('No allowedPrefixes parameter found in policy');
    }
    const allowedPrefixes = JSON.parse(ethers.utils.toUtf8String(allowedPrefixesParam.value));
    if (!allowedPrefixes.length) {
        throw new Error('No allowed prefixes defined in policy');
    }
    // Check if message starts with any allowed prefix
    const messageHasAllowedPrefix = allowedPrefixes.some((prefix) => toolParameters.message.startsWith(prefix));
    if (!messageHasAllowedPrefix) {
        throw new Error(`Message must start with one of these prefixes: ${allowedPrefixes.join(', ')}`);
    }
    console.log('Message prefix validated successfully');
})();
