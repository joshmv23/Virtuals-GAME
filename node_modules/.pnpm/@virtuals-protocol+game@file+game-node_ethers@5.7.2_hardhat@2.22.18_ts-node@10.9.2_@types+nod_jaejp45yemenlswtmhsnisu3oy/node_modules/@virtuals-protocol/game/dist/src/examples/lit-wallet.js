"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.litWalletWorker = exports.initializePKPWallet = exports.pkpWallet = exports.litNodeClient = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const game_1 = require("@virtuals-protocol/game");
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const pkp_ethers_1 = require("@lit-protocol/pkp-ethers");
const ethers_1 = require("ethers");
const auth_helpers_1 = require("@lit-protocol/auth-helpers");
const constants_1 = require("@lit-protocol/constants");
// ERC20 Interface
const ERC20_ABI = [
    "function balanceOf(address owner) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)"
];
// Initialize Lit Client
exports.litNodeClient = new lit_node_client_1.LitNodeClient({
    litNetwork: 'datil-test',
    debug: true,
    minNodeCount: 2
});
// Configuration
const UNISWAP_ROUTER = '0xE592427A0AEce92De3Edee1F18E0157C05861564';
const WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
// Initialize PKP wallet
const initializePKPWallet = (pkpPublicKey) => __awaiter(void 0, void 0, void 0, function* () {
    if (!exports.litNodeClient.ready)
        yield exports.litNodeClient.connect();
    const provider = new ethers_1.ethers.providers.JsonRpcProvider(constants_1.LIT_RPC.CHRONICLE_YELLOWSTONE);
    const wallet = new ethers_1.ethers.Wallet(process.env.PRIVATE_KEY || "", provider);
    const resourceAbilities = [{
            resource: new auth_helpers_1.LitActionResource('*'),
            ability: constants_1.LIT_ABILITY.LitActionExecution
        }];
    const sessionSigs = yield exports.litNodeClient.getSessionSigs({
        chain: "ethereum",
        expiration: new Date(Date.now() + 60000 * 60).toISOString(),
        resourceAbilityRequests: resourceAbilities,
        authNeededCallback: (_a) => __awaiter(void 0, [_a], void 0, function* ({ resourceAbilityRequests, expiration, uri }) {
            const toSign = yield (0, auth_helpers_1.createSiweMessageWithRecaps)({
                uri: 'https://localhost/login',
                expiration: expiration || new Date(Date.now() + 60000 * 60).toISOString(),
                resources: resourceAbilityRequests || [],
                walletAddress: yield wallet.getAddress(),
                nonce: yield exports.litNodeClient.getLatestBlockhash(),
                litNodeClient: exports.litNodeClient,
            });
            return yield (0, auth_helpers_1.generateAuthSig)({
                signer: wallet,
                toSign,
            });
        }),
    });
    const newPkpWallet = new pkp_ethers_1.PKPEthersWallet({
        pkpPubKey: pkpPublicKey,
        provider,
        litNodeClient: exports.litNodeClient,
        authContext: {
            getSessionSigsProps: {
                chain: "ethereum",
                resourceAbilityRequests: resourceAbilities,
                authNeededCallback: () => __awaiter(void 0, void 0, void 0, function* () {
                    return ({
                        sig: "test",
                        derivedVia: "web3.eth.personal.sign",
                        signedMessage: "test",
                        address: yield wallet.getAddress()
                    });
                })
            }
        }
    });
    yield newPkpWallet.init();
    exports.pkpWallet = newPkpWallet;
    return exports.pkpWallet;
});
exports.initializePKPWallet = initializePKPWallet;
// Add Uniswap Router ABI
const SWAP_ROUTER_ABI = [
    'function exactInputSingle(tuple(address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96) params) external payable returns (uint256 amountOut)',
];
// Wallet Functions
const swapTokensFunction = new game_1.GameFunction({
    name: "swap_tokens",
    description: "Swap tokens using Lit Agent Wallet via Uniswap",
    args: [
        { name: "tokenIn", description: "Token address to swap from" },
        { name: "tokenOut", description: "Token address to swap to" },
        { name: "amount", description: "Amount to swap in wei" },
        { name: "slippage", description: "Maximum slippage percentage", optional: true },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!exports.pkpWallet)
                throw new Error("PKP wallet not initialized");
            if (typeof args.tokenIn !== 'string')
                throw new Error("Invalid tokenIn address");
            if (typeof args.tokenOut !== 'string')
                throw new Error("Invalid tokenOut address");
            logger(`Initiating swap of ${args.amount} ${args.tokenIn} to ${args.tokenOut}`);
            logger(`Slippage set to: ${args.slippage || '0.5'}%`);
            // If tokenIn is not ETH, approve Uniswap router
            if (args.tokenIn !== 'ETH') {
                const tokenContract = new ethers_1.ethers.Contract(args.tokenIn, ERC20_ABI, exports.pkpWallet);
                const approveTx = yield tokenContract.approve(UNISWAP_ROUTER, args.amount);
                yield approveTx.wait();
                logger('Approved token for swap');
            }
            // Initialize Uniswap Router contract
            const router = new ethers_1.ethers.Contract(UNISWAP_ROUTER, SWAP_ROUTER_ABI, exports.pkpWallet);
            // Prepare swap parameters
            const params = {
                tokenIn: args.tokenIn === 'ETH' ? WETH_ADDRESS : args.tokenIn,
                tokenOut: args.tokenOut === 'ETH' ? WETH_ADDRESS : args.tokenOut,
                fee: 3000, // 0.3% fee tier
                recipient: yield exports.pkpWallet.getAddress(),
                deadline: Math.floor(Date.now() / 1000) + 60 * 20, // 20 minutes from now
                amountIn: args.amount,
                amountOutMinimum: 0, // Set this based on price impact calculation
                sqrtPriceLimitX96: 0,
            };
            // Execute swap
            const tx = yield router.exactInputSingle(params, {
                value: args.tokenIn === 'ETH' ? args.amount : 0,
                gasLimit: 300000,
            });
            yield tx.wait();
            logger('Swap executed successfully');
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Swap completed: ${args.amount} ${args.tokenIn} -> ${args.tokenOut}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to swap tokens: ${error.message}`);
        }
    }),
});
const transferTokensFunction = new game_1.GameFunction({
    name: "transfer_token",
    description: "Transfer tokens using Lit Agent Wallet",
    args: [
        { name: "token", description: "Token contract address or 'ETH' for native token" },
        { name: "recipient", description: "Recipient address" },
        { name: "amount", description: "Amount to transfer (in token units, not wei)" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!exports.pkpWallet)
                throw new Error("PKP wallet not initialized");
            if (!args.token || !args.recipient || !args.amount)
                throw new Error("Missing required arguments");
            logger(`Initiating transfer of ${args.amount} tokens to ${args.recipient}`);
            let tx;
            let receipt;
            if (args.token === 'ETH') {
                const amountWei = ethers_1.ethers.utils.parseEther(args.amount);
                tx = yield exports.pkpWallet.sendTransaction({
                    to: args.recipient,
                    value: amountWei
                });
            }
            else {
                const tokenContract = new ethers_1.ethers.Contract(args.token, ERC20_ABI, exports.pkpWallet);
                const decimals = yield tokenContract.decimals();
                const amountInTokenUnits = ethers_1.ethers.utils.parseUnits(args.amount, decimals);
                tx = yield tokenContract.transfer(args.recipient, amountInTokenUnits);
            }
            logger(`Transaction sent with hash: ${tx.hash}`);
            receipt = yield tx.wait();
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Transfer complete! Transaction hash: ${receipt.transactionHash}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to transfer tokens: ${error.message}`);
        }
    }),
});
const checkBalanceFunction = new game_1.GameFunction({
    name: "check_balance",
    description: "Check token balance in Lit Agent Wallet",
    args: [
        { name: "token", description: "Token contract address or 'ETH' for native token" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!exports.pkpWallet)
                throw new Error("PKP wallet not initialized");
            if (!args.token)
                throw new Error("Token address is required");
            logger(`Checking balance for ${args.token}`);
            let balance;
            let symbol;
            let decimals;
            if (args.token === 'ETH') {
                balance = yield exports.pkpWallet.getBalance();
                symbol = 'ETH';
                decimals = 18;
            }
            else {
                const tokenContract = new ethers_1.ethers.Contract(args.token, ERC20_ABI, exports.pkpWallet);
                balance = yield tokenContract.balanceOf(yield exports.pkpWallet.getAddress());
                symbol = yield tokenContract.symbol();
                decimals = yield tokenContract.decimals();
            }
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Balance: ${ethers_1.ethers.utils.formatUnits(balance, decimals)} ${symbol}`);
        }
        catch (error) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to check balance: ${error.message}`);
        }
    }),
});
// Create a worker with the wallet functions
exports.litWalletWorker = new game_1.GameWorker({
    id: "lit_wallet_worker",
    name: "Lit Wallet Worker",
    description: "Worker that handles Lit Protocol wallet operations",
    functions: [swapTokensFunction, transferTokensFunction, checkBalanceFunction],
    getEnvironment: () => __awaiter(void 0, void 0, void 0, function* () {
        return {
            network: "datil-test",
            chainId: 175177, // Chronicle Yellowstone testnet
            pkpPublicKey: process.env.PKP_PUBLIC_KEY,
            rpcUrl: constants_1.LIT_RPC.CHRONICLE_YELLOWSTONE,
        };
    }),
});
// Create an agent with the worker
const agent = new game_1.GameAgent(process.env.VIRTUALS_API_KEY || "YOUR_API_KEY", {
    name: "Lit Wallet Agent",
    goal: "Manage wallet operations using Lit Protocol",
    description: "An agent that can perform wallet operations like swaps and transfers using Lit Protocol",
    workers: [exports.litWalletWorker],
});
// Example usage
(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Initialize provider
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(constants_1.LIT_RPC.CHRONICLE_YELLOWSTONE);
        // Create two regular wallets
        const wallet1 = new ethers_1.ethers.Wallet(process.env.PRIVATE_KEY || "", provider);
        const wallet2 = new ethers_1.ethers.Wallet(process.env.PRIVATE_KEY_2 || "", provider);
        console.log("\nWallet Addresses:");
        console.log("Wallet 1 (Sender):", yield wallet1.getAddress());
        console.log("Wallet 2 (Recipient):", yield wallet2.getAddress());
        // Check initial balances
        console.log("\nInitial balances:");
        const wallet1InitialBalance = yield wallet1.getBalance();
        const wallet2InitialBalance = yield wallet2.getBalance();
        console.log("Wallet 1 balance:", ethers_1.ethers.utils.formatEther(wallet1InitialBalance), "ETH");
        console.log("Wallet 2 balance:", ethers_1.ethers.utils.formatEther(wallet2InitialBalance), "ETH");
        // Transfer ETH from wallet1 to wallet2
        console.log("\nTransferring 0.001 ETH from Wallet 1 to Wallet 2...");
        const tx = yield wallet1.sendTransaction({
            to: wallet2.address,
            value: ethers_1.ethers.utils.parseEther("0.001"), // Sending 0.001 ETH
            gasLimit: 300000,
        });
        console.log("Transaction hash:", tx.hash);
        yield tx.wait();
        console.log("Transfer completed!");
        // Check final balances
        console.log("\nFinal balances:");
        const wallet1FinalBalance = yield wallet1.getBalance();
        const wallet2FinalBalance = yield wallet2.getBalance();
        console.log("Wallet 1 balance:", ethers_1.ethers.utils.formatEther(wallet1FinalBalance), "ETH");
        console.log("Wallet 2 balance:", ethers_1.ethers.utils.formatEther(wallet2FinalBalance), "ETH");
        // Calculate and display the changes
        console.log("\nBalance changes:");
        console.log("Wallet 1 change:", ethers_1.ethers.utils.formatEther(wallet1FinalBalance.sub(wallet1InitialBalance)), "ETH");
        console.log("Wallet 2 change:", ethers_1.ethers.utils.formatEther(wallet2FinalBalance.sub(wallet2InitialBalance)), "ETH");
    }
    catch (error) {
        console.error("Error:", error.message);
    }
}))();
