"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
const constants_1 = require("../../constants");
const get_token_1 = require("./utils/get-token");
const sdk_1 = require("@ensofinance/sdk");
const utils_1 = require("ethers/lib/utils");
const get_route_1 = require("./utils/get-route");
const approve_1 = require("./utils/approve");
const sign_tx_1 = require("./utils/sign-tx");
const broadcast_tx_1 = require("./utils/broadcast-tx");
const get_gas_data_1 = require("./utils/get-gas-data");
const create_route_tx_1 = require("./utils/create-route-tx");
(async () => {
    try {
        console.log(`Using Lit Network: ${LIT_NETWORK}`);
        console.log(`Using PKP Tool Registry Address: ${PKP_TOOL_REGISTRY_ADDRESS}`);
        console.log(`Using Pubkey Router Address: ${aw_tool_1.NETWORK_CONFIG[LIT_NETWORK]
            .pubkeyRouterAddress}`);
        if (!constants_1.ENSO_SUPPORTED_CHAINS.has(Number(params.chainId))) {
            throw new Error(`ChainId ${params.chainId} is not supported by Enso`);
        }
        const delegateeAddress = ethers.utils.getAddress(LitAuth.authSigAddress);
        const toolIpfsCid = LitAuth.actionIpfsIds[0];
        const ensoClient = new sdk_1.EnsoClient({ apiKey: constants_1.ENSO_API_KEY });
        const chainId = Number(params.chainId);
        const provider = new ethers.providers.JsonRpcProvider(params.rpcUrl);
        const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(PKP_TOOL_REGISTRY_ADDRESS);
        const pkp = await (0, aw_tool_1.getPkpInfo)(params.pkpEthAddress);
        const toolPolicy = await (0, aw_tool_1.fetchToolPolicyFromRegistry)(pkpToolRegistryContract, pkp.tokenId, delegateeAddress, toolIpfsCid);
        const tokenInData = await (0, get_token_1.getToken)(ensoClient, chainId, params.tokenIn);
        const amountInWei = (0, utils_1.parseUnits)(params.amountIn, tokenInData.decimals).toString();
        if (toolPolicy.enabled &&
            toolPolicy.policyIpfsCid !== undefined &&
            toolPolicy.policyIpfsCid !== '0x' &&
            toolPolicy.policyIpfsCid !== '') {
            console.log(`Executing policy ${toolPolicy.policyIpfsCid}`);
            await Lit.Actions.call({
                ipfsId: toolPolicy.policyIpfsCid,
                params: {
                    parentToolIpfsCid: toolIpfsCid,
                    pkpToolRegistryContractAddress: PKP_TOOL_REGISTRY_ADDRESS,
                    pkpTokenId: pkp.tokenId,
                    delegateeAddress,
                    toolParameters: {
                        amountIn: amountInWei,
                        tokenIn: params.tokenIn,
                        tokenOut: params.tokenOut,
                    },
                },
            });
        }
        else {
            console.log(`No policy found for tool ${toolIpfsCid} on PKP ${pkp.tokenId} for delegatee ${delegateeAddress}`);
        }
        // Add your tool execution logic here
        const routeData = await (0, get_route_1.getRoute)(ensoClient, chainId, pkp.ethAddress, params.tokenIn, amountInWei, params.tokenOut);
        if (params.tokenIn.toLowerCase() !== constants_1.ENSO_ETH) {
            const gasData = await (0, get_gas_data_1.getGasData)(provider, pkp.ethAddress);
            const approveTx = await (0, approve_1.createApproveTx)(ensoClient, chainId, gasData, pkp.ethAddress, tokenInData.address, amountInWei);
            const signedApprovalTx = await (0, sign_tx_1.signTx)(pkp.publicKey, approveTx, 'erc20ApprovalSig');
            const approvalHash = await (0, broadcast_tx_1.broadcastTransaction)(provider, signedApprovalTx);
            console.log('Approval transaction hash:', approvalHash);
            // Wait for approval confirmation
            console.log('Waiting for approval confirmation...');
            const approvalConfirmation = await provider.waitForTransaction(approvalHash, 1);
            if (approvalConfirmation.status === 0) {
                throw new Error('Approval transaction failed');
            }
        }
        const gasData = await (0, get_gas_data_1.getGasData)(provider, pkp.ethAddress);
        const routeTx = await (0, create_route_tx_1.createRouteTx)(routeData, gasData, chainId);
        const signedRouteTx = await (0, sign_tx_1.signTx)(pkp.publicKey, routeTx, 'erc20RouteSig');
        const routeHash = await (0, broadcast_tx_1.broadcastTransaction)(provider, signedRouteTx);
        console.log('Route transaction hash', routeHash);
        Lit.Actions.setResponse({
            response: JSON.stringify({
                routeHash,
                status: 'success',
            }),
        });
    }
    catch (err) {
        console.error('Error:', err);
        // Extract detailed error information
        const errorDetails = {
            message: err.message,
            code: err.code,
            reason: err.reason,
            error: err.error,
            ...(err.transaction && { transaction: err.transaction }),
            ...(err.receipt && { receipt: err.receipt }),
        };
        Lit.Actions.setResponse({
            response: JSON.stringify({
                status: 'error',
                error: err.message || String(err),
                details: errorDetails,
            }),
        });
    }
})();
