"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const game_1 = require("@virtuals-protocol/game");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const client_s3_1 = require("@aws-sdk/client-s3");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
/**
 * S3Plugin class
 */
class S3Plugin {
    constructor(options) {
        this.id = options.id || "s3_worker";
        this.name = options.name || "S3 Worker";
        this.description =
            options.description ||
                "A worker that will execute tasks with S3-compatible bucket storage. It is capable of uploading and downloading files.";
        this.s3Client = new client_s3_1.S3Client(Object.assign(Object.assign(Object.assign(Object.assign({}, (options.endpoint ? { endpoint: options.endpoint } : {})), (options.sslEnabled ? { sslEnabled: options.sslEnabled } : {})), (options.forcePathStyle
            ? { forcePathStyle: Boolean(options.forcePathStyle) }
            : {})), { region: options.region, credentials: {
                accessKeyId: options.credentials.accessKeyId,
                secretAccessKey: options.credentials.secretAccessKey,
            } }));
        this.bucket = options.bucket;
    }
    getWorker(data) {
        return new game_1.GameWorker({
            id: this.id,
            name: this.name,
            description: this.description,
            functions: (data === null || data === void 0 ? void 0 : data.functions) || [
                this.uploadFileFunction,
                this.downloadFileFunction,
            ],
            getEnvironment: data === null || data === void 0 ? void 0 : data.getEnvironment,
        });
    }
    /**
     * Upload a file to S3
     * @returns The upload file function
     */
    get uploadFileFunction() {
        return new game_1.GameFunction({
            name: "upload_file",
            description: "Upload a file to S3",
            args: [
                {
                    name: "file_path",
                    description: "The file path to upload from or download to.",
                },
                {
                    name: "object_key",
                    description: "Optional: The object key to upload the file to. If not provided, internal logic will generate a unique key. DO NOT define a key if it is not explicitly provided (default: `timestamp-file_name`)",
                },
                {
                    name: "use_signed_url",
                    description: "Optional: Whether to use a signed URL or default the standard access URL (default: false)",
                },
                {
                    name: "ttl",
                    description: "Optional: If using a signed URL, the expiration time for the signed URL in seconds (default: 3600 seconds)",
                },
            ],
            executable: (args, logger) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!args.file_path || !(0, node_fs_1.existsSync)(args.file_path)) {
                        return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "File path is required and must exist");
                    }
                    const filePath = args.file_path;
                    const fileContent = (0, node_fs_1.readFileSync)(filePath);
                    const objectKey = args.object_key
                        ? args.object_key
                        : `${Date.now()}-${(0, node_path_1.basename)(filePath)}`;
                    logger(`Uploading file '${args.file_path}' at key '${objectKey}'`);
                    yield this.s3Client.send(new client_s3_1.PutObjectCommand({
                        Bucket: this.bucket,
                        Key: objectKey,
                        Body: fileContent,
                        ContentType: this.getContentType(filePath),
                    }));
                    let result = {
                        success: true,
                    };
                    if (!args.use_signed_url) {
                        if (this.s3Client.config.endpoint) {
                            const endpoint = yield this.s3Client.config.endpoint();
                            const port = endpoint.port ? `:${endpoint.port}` : "";
                            result.url = `${endpoint.protocol}//${endpoint.hostname}${port}${endpoint.path}${this.bucket}/${objectKey}`;
                        }
                        else {
                            result.url = `https://${this.bucket}.s3.${process.env.AWS_REGION}.amazonaws.com/${objectKey}`;
                        }
                    }
                    else {
                        const expiresIn = args.ttl || 3600; // 1 hour
                        const getObjectCommand = new client_s3_1.GetObjectCommand({
                            Bucket: this.bucket,
                            Key: objectKey,
                        });
                        result.url = yield (0, s3_request_presigner_1.getSignedUrl)(this.s3Client, getObjectCommand, {
                            expiresIn,
                        });
                    }
                    const feedbackMessage = "File uploaded:\n" + JSON.stringify(result);
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, feedbackMessage);
                }
                catch (e) {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to upload file: ${e}`);
                }
            }),
        });
    }
    /**
     * Download a file from S3 to a local file path
     * @returns The download file function
     */
    get downloadFileFunction() {
        return new game_1.GameFunction({
            name: "download_file",
            description: "Download a file from S3",
            args: [
                {
                    name: "object_key",
                    description: "The object key to download the file from",
                },
                {
                    name: "file_path",
                    description: "File path to download the file to",
                },
            ],
            executable: (args, logger) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    if (!args.object_key || !args.file_path) {
                        return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Object key and file path are required");
                    }
                    logger(`Downloading object at key '${args.object_key}'`);
                    const response = yield this.s3Client.send(new client_s3_1.GetObjectCommand({
                        Bucket: this.bucket,
                        Key: args.object_key,
                    }));
                    const fileContent = yield ((_a = response.Body) === null || _a === void 0 ? void 0 : _a.transformToByteArray());
                    if (!fileContent) {
                        return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to download file");
                    }
                    (0, node_fs_1.writeFileSync)(args.file_path, fileContent);
                    const feedbackMessage = `File downloaded to: ${args.file_path}`;
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, feedbackMessage);
                }
                catch (e) {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed to download file: ${e}`);
                }
            }),
        });
    }
    /**
     * Helper function to get the content type of a file
     * @param filePath - The file path to get the content type of
     * @returns The content type of the file
     */
    getContentType(filePath) {
        const ext = (0, node_path_1.extname)(filePath).toLowerCase();
        const contentTypes = {
            ".png": "image/png",
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".gif": "image/gif",
            ".webp": "image/webp",
        };
        return contentTypes[ext] || "application/octet-stream";
    }
}
exports.default = S3Plugin;
