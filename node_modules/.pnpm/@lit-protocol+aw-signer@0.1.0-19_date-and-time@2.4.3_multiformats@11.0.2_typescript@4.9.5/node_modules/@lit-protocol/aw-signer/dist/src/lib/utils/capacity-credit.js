"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requiresCapacityCredit = requiresCapacityCredit;
exports.isCapacityCreditExpired = isCapacityCreditExpired;
exports.mintCapacityCredit = mintCapacityCredit;
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const errors_1 = require("../errors");
/**
 * Check if the current network requires capacity credits
 */
function requiresCapacityCredit(litContracts) {
    return (litContracts.network === constants_1.LIT_NETWORK.DatilTest ||
        litContracts.network === constants_1.LIT_NETWORK.Datil);
}
function isCapacityCreditExpired(mintedAtUtc, daysUntilUTCMidnightExpiration) {
    // Create dates from UTC timestamps
    const now = new Date();
    const mintedDate = new Date(mintedAtUtc);
    // Calculate the expiration date at UTC midnight
    const expirationDate = new Date(mintedDate);
    expirationDate.setUTCDate(mintedDate.getUTCDate() + daysUntilUTCMidnightExpiration);
    expirationDate.setUTCHours(0, 0, 0, 0); // Set to UTC midnight
    // Expire 10 minutes before UTC midnight
    const earlyExpirationMinutes = 10;
    const earlyExpirationMilliseconds = earlyExpirationMinutes * 60 * 1000;
    // Compare timestamps in UTC
    return now.getTime() > expirationDate.getTime() - earlyExpirationMilliseconds;
}
/**
 * Mint a new capacity credit NFT
 */
async function mintCapacityCredit(litContracts, { requestsPerKilosecond = 10, daysUntilUTCMidnightExpiration = 1, } = {}) {
    // Calculate expiration timestamp at UTC midnight
    const now = new Date();
    const expirationDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + daysUntilUTCMidnightExpiration, 0, 0, 0, 0 // Set to midnight UTC
    ));
    const expiresAt = Math.floor(expirationDate.getTime() / 1000); // Convert to Unix timestamp
    const mintCost = await litContracts.rateLimitNftContract.read.calculateCost(requestsPerKilosecond, expiresAt);
    if (mintCost.gt(await litContracts.signer.getBalance())) {
        throw new errors_1.AwSignerError(errors_1.AwSignerErrorType.INSUFFICIENT_BALANCE_CAPACITY_CREDIT_MINT, `${await litContracts.signer.getAddress()} has insufficient balance to mint capacity credit: ${ethers_1.ethers.utils.formatEther(await litContracts.signer.getBalance())} < ${ethers_1.ethers.utils.formatEther(mintCost)}`);
    }
    const capacityCreditInfo = await litContracts.mintCapacityCreditsNFT({
        requestsPerKilosecond,
        daysUntilUTCMidnightExpiration,
    });
    return {
        capacityTokenIdStr: capacityCreditInfo.capacityTokenIdStr,
        capacityTokenId: capacityCreditInfo.capacityTokenId,
        requestsPerKilosecond,
        daysUntilUTCMidnightExpiration,
        mintedAtUtc: new Date().toISOString(),
    };
}
