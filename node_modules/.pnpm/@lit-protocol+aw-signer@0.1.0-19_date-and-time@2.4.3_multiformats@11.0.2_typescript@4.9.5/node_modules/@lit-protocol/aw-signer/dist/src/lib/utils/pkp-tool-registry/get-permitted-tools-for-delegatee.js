"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermittedToolsForDelegatee = void 0;
const aw_tool_registry_1 = require("@lit-protocol/aw-tool-registry");
/**
 * Process a tool that isn't found in the registry
 */
const processUnknownTool = (toolInfo, hasPolicy, result) => {
    if (hasPolicy) {
        result.toolsUnknownWithPolicies[toolInfo.toolIpfsCid] = {
            toolIpfsCid: toolInfo.toolIpfsCid,
            toolEnabled: toolInfo.toolEnabled,
            delegatee: toolInfo.delegatee,
            policyIpfsCid: toolInfo.policyIpfsCid,
            policyEnabled: toolInfo.policyEnabled,
        };
    }
    else {
        result.toolsUnknownWithoutPolicies.push({
            toolIpfsCid: toolInfo.toolIpfsCid,
            toolEnabled: toolInfo.toolEnabled,
            delegatee: toolInfo.delegatee,
        });
    }
};
/**
 * Process a tool that is found in the registry
 */
const processKnownTool = (toolInfo, hasPolicy, registryTool, result) => {
    const baseToolInfo = {
        name: registryTool.tool.name,
        description: registryTool.tool.description,
        ipfsCid: registryTool.tool.ipfsCid,
        parameters: registryTool.tool.parameters,
        policy: registryTool.tool.policy,
        network: registryTool.network,
        toolEnabled: toolInfo.toolEnabled,
        delegatee: toolInfo.delegatee,
        defaultPolicyIpfsCid: registryTool.tool.defaultPolicyIpfsCid,
    };
    if (hasPolicy) {
        result.toolsWithPolicies[toolInfo.toolIpfsCid] = {
            ...baseToolInfo,
            policyIpfsCid: toolInfo.policyIpfsCid,
            policyEnabled: toolInfo.policyEnabled,
        };
    }
    else {
        result.toolsWithoutPolicies[toolInfo.toolIpfsCid] = baseToolInfo;
    }
};
/**
 * Process a single tool from the registry
 */
const processRegistryTool = async (toolInfo, result) => {
    const hasPolicy = toolInfo.policyIpfsCid !== '';
    const registryTool = await (0, aw_tool_registry_1.getToolByIpfsCid)(toolInfo.toolIpfsCid);
    if (registryTool === null) {
        processUnknownTool(toolInfo, hasPolicy, result);
    }
    else {
        processKnownTool(toolInfo, hasPolicy, registryTool, result);
    }
};
/**
 * Get all tools that are permitted for a specific delegatee
 * @returns Object containing:
 * - toolsWithPolicies: Object mapping tool IPFS CIDs to tools that have policies and match the current network
 * - toolsWithoutPolicies: Object mapping tool IPFS CIDs to tools that don't have policies and match the current network
 * - toolsUnknownWithPolicies: Object mapping tool IPFS CIDs to tools with policies that aren't in the registry
 * - toolsUnknownWithoutPolicies: Array of tools without policies that aren't in the registry
 */
const getPermittedToolsForDelegatee = async (toolPolicyRegistryContract, pkpTokenId, delegatee) => {
    // Get tools permitted for this delegatee from registry contract
    const toolsInfo = await toolPolicyRegistryContract.getPermittedToolsForDelegatee(pkpTokenId, delegatee);
    const result = {
        toolsWithPolicies: {},
        toolsWithoutPolicies: {},
        toolsUnknownWithPolicies: {},
        toolsUnknownWithoutPolicies: [],
    };
    // Process each tool from the registry
    await Promise.all(toolsInfo.map((toolInfo) => processRegistryTool(toolInfo, result)));
    return result;
};
exports.getPermittedToolsForDelegatee = getPermittedToolsForDelegatee;
