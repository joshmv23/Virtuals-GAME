"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delegatee = void 0;
const contracts_sdk_1 = require("@lit-protocol/contracts-sdk");
const lit_node_client_nodejs_1 = require("@lit-protocol/lit-node-client-nodejs");
const auth_helpers_1 = require("@lit-protocol/auth-helpers");
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const capacity_credit_1 = require("./utils/capacity-credit");
const storage_1 = require("./utils/storage");
const errors_1 = require("./errors");
const pkp_tool_registry_1 = require("./utils/pkp-tool-registry");
/**
 * The `Delegatee` class is responsible for executing tools on behalf of the PKP Admin.
 * They are limited to the tools and policies that the PKP Admin has permitted. The class
 * manages the delegatee's authentication and wallet, retrieves permitted tools and their
 * policies, executes tools within permitted boundaries, manages tool-specific credentials,
 * and handles capacity credits for execution. It provides secure access to authorized tools
 * while enforcing policy constraints set by the PKP Admin.
 */
class Delegatee {
    static DEFAULT_STORAGE_PATH = './.law-signer-delegatee-storage';
    static DELEGATEE_STORAGE_KEY = 'delegatees';
    storage;
    litNodeClient;
    litContracts;
    toolRegistryContract;
    delegateeWallet;
    litNetwork;
    /**
     * Private constructor for the Delegatee class.
     * @param litNetwork - The Lit network to use.
     * @param storage - An instance of `LocalStorage` for storing delegatee information.
     * @param litNodeClient - An instance of `LitNodeClientNodeJs`.
     * @param litContracts - An instance of `LitContracts`.
     * @param toolRegistryContract - An instance of the tool policy registry contract.
     * @param delegateeWallet - The wallet used for Delegatee operations.
     */
    constructor(litNetwork, storage, litNodeClient, litContracts, toolRegistryContract, delegateeWallet) {
        this.litNetwork = litNetwork;
        this.storage = storage;
        this.litNodeClient = litNodeClient;
        this.litContracts = litContracts;
        this.toolRegistryContract = toolRegistryContract;
        this.delegateeWallet = delegateeWallet;
    }
    static loadDelegateesFromStorage(storage) {
        const delegateeData = storage.getItem(Delegatee.DELEGATEE_STORAGE_KEY);
        if (!delegateeData) {
            return {};
        }
        return JSON.parse(delegateeData);
    }
    static saveDelegateesToStorage(storage, delegatees) {
        storage.setItem(Delegatee.DELEGATEE_STORAGE_KEY, JSON.stringify(delegatees));
    }
    /**
     * Retrieves or mints a capacity credit for the Delegatee.
     * If a capacity credit is already stored and not expired, it is loaded; otherwise, a new capacity credit is minted.
     *
     * @param litContracts - An instance of `LitContracts`.
     * @param storage - An instance of `LocalStorage` for storing capacity credit information.
     * @param delegateeAddress - The address of the delegatee.
     * @returns A promise that resolves to the capacity credit information or `null` if not required.
     */
    static async getCapacityCredit(litContracts, storage, delegateeAddress) {
        if ((0, capacity_credit_1.requiresCapacityCredit)(litContracts)) {
            const delegatees = Delegatee.loadDelegateesFromStorage(storage);
            const capacityCreditInfo = delegatees[delegateeAddress]?.capacityCredit || null;
            if (capacityCreditInfo !== null &&
                !(0, capacity_credit_1.isCapacityCreditExpired)(capacityCreditInfo.mintedAtUtc, capacityCreditInfo.daysUntilUTCMidnightExpiration)) {
                return capacityCreditInfo;
            }
            const mintMetadata = await (0, capacity_credit_1.mintCapacityCredit)(litContracts);
            // Update storage with new capacity credit
            if (!delegatees[delegateeAddress]) {
                delegatees[delegateeAddress] = { privateKey: '' };
            }
            delegatees[delegateeAddress].capacityCredit = mintMetadata;
            Delegatee.saveDelegateesToStorage(storage, delegatees);
            return mintMetadata;
        }
        return null;
    }
    /**
     * Creates an instance of the `Delegatee` class.
     * Initializes the Lit node client, contracts, and capacity credit.
     *
     * @param delegateePrivateKey - Optional. The private key for the Delegatee role.
     * @param agentConfig - Configuration for the agent, including the Lit network and debug mode.
     * @returns A promise that resolves to an instance of the `Delegatee` class.
     * @throws {AwSignerError} If the Lit network is not provided or the private key is missing.
     */
    static async create(delegateePrivateKey, { litNetwork, debug = false } = {}) {
        if (!litNetwork) {
            throw new errors_1.AwSignerError(errors_1.AwSignerErrorType.DELEGATEE_MISSING_LIT_NETWORK, 'Lit network not provided');
        }
        const storage = new storage_1.LocalStorage(Delegatee.DEFAULT_STORAGE_PATH);
        const toolPolicyRegistryConfig = pkp_tool_registry_1.DEFAULT_REGISTRY_CONFIG[litNetwork];
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(toolPolicyRegistryConfig.rpcUrl);
        // Create temporary wallet to get address for storage lookup
        const tempWallet = delegateePrivateKey
            ? new ethers_1.ethers.Wallet(delegateePrivateKey)
            : null;
        const delegatees = Delegatee.loadDelegateesFromStorage(storage);
        const delegateeData = tempWallet ? delegatees[tempWallet.address] : null;
        const _delegateePrivateKey = delegateePrivateKey || delegateeData?.privateKey;
        if (_delegateePrivateKey === null || _delegateePrivateKey === undefined) {
            throw new errors_1.AwSignerError(errors_1.AwSignerErrorType.DELEGATEE_MISSING_PRIVATE_KEY, 'Delegatee private key not provided and not found in storage. Please provide a private key.');
        }
        const delegateeWallet = new ethers_1.ethers.Wallet(_delegateePrivateKey, provider);
        // Save delegatee data if not already stored
        if (!delegateeData) {
            delegatees[delegateeWallet.address] = {
                privateKey: _delegateePrivateKey,
            };
            Delegatee.saveDelegateesToStorage(storage, delegatees);
        }
        const litNodeClient = new lit_node_client_nodejs_1.LitNodeClientNodeJs({
            litNetwork,
            debug,
        });
        await litNodeClient.connect();
        const litContracts = new contracts_sdk_1.LitContracts({
            signer: delegateeWallet,
            network: litNetwork,
            debug,
        });
        await litContracts.connect();
        // Will mint a Capacity Credit if none exists
        await Delegatee.getCapacityCredit(litContracts, storage, delegateeWallet.address);
        return new Delegatee(litNetwork, storage, litNodeClient, litContracts, (0, pkp_tool_registry_1.getPkpToolRegistryContract)(toolPolicyRegistryConfig, delegateeWallet), delegateeWallet);
    }
    /**
     * Retrieves all delegated PKPs (Programmable Key Pairs) for the Delegatee.
     * @returns A promise that resolves to an array of `DelegatedPkpInfo` objects.
     * @throws If the tool policy registry contract, delegatee wallet, or Lit contracts are not initialized.
     */
    async getDelegatedPkps() {
        if (!this.toolRegistryContract) {
            throw new Error('Tool policy manager not initialized');
        }
        if (!this.delegateeWallet) {
            throw new Error('Delegatee wallet not initialized');
        }
        if (!this.litContracts) {
            throw new Error('Lit contracts not initialized');
        }
        // Get token IDs of delegated PKPs
        const tokenIds = await this.toolRegistryContract.getDelegatedPkps(this.delegateeWallet.address);
        // For each token ID, get the public key and compute eth address
        const pkps = await Promise.all(tokenIds.map(async (tokenId) => {
            // Get PKP public key
            const pkpInfo = await this.litContracts.pkpNftContract.read.getPubkey(tokenId);
            const publicKey = pkpInfo.toString();
            // Compute eth address from public key
            const ethAddress = ethers_1.ethers.utils.computeAddress(publicKey);
            return {
                tokenId: ethers_1.ethers.utils.hexlify(tokenId),
                ethAddress,
                publicKey,
            };
        }));
        return pkps;
    }
    /**
     * Get all registered tools and categorize them based on whether they have policies
     * @returns Object containing:
     * - toolsWithPolicies: Object mapping tool IPFS CIDs to their metadata and delegatee policies
     * - toolsWithoutPolicies: Array of tools that don't have policies
     * - toolsUnknownWithPolicies: Object mapping unknown tool IPFS CIDs to their delegatee policies
     * - toolsUnknownWithoutPolicies: Array of tool CIDs without policies that aren't in the registry
     */
    async getPermittedToolsForPkp(pkpTokenId) {
        if (!this.toolRegistryContract) {
            throw new Error('Tool policy manager not initialized');
        }
        return (0, pkp_tool_registry_1.getPermittedToolsForDelegatee)(this.toolRegistryContract, pkpTokenId, this.delegateeWallet.address);
    }
    /**
     * Retrieves the policy for a specific tool.
     * @param pkpTokenId - The token ID of the PKP.
     * @param ipfsCid - The IPFS CID of the tool.
     * @returns An object containing the policy and version for the tool.
     * @throws If the tool policy registry contract is not initialized.
     */
    async getToolPolicy(pkpTokenId, ipfsCid) {
        if (!this.toolRegistryContract) {
            throw new Error('Tool policy manager not initialized');
        }
        const results = await this.toolRegistryContract.getToolPoliciesForDelegatees(pkpTokenId, [ipfsCid], [this.delegateeWallet.address]);
        return results[0];
    }
    /**
     * Matches a user's intent to an appropriate permitted tool.
     * @param pkpTokenId - The token ID of the PKP.
     * @param intent - The user's intent string.
     * @param intentMatcher - The intent matcher implementation to use.
     * @returns A promise that resolves to the matched tool and any extracted parameters.
     * @throws If no matching tool is found or if the tool is not permitted.
     */
    async getToolViaIntent(pkpTokenId, intent, intentMatcher) {
        // Get registered tools
        const { toolsWithPolicies, toolsWithoutPolicies } = await this.getPermittedToolsForPkp(pkpTokenId);
        // Analyze intent and find matching tool
        return intentMatcher.analyzeIntentAndMatchTool(intent, [
            ...Object.values(toolsWithPolicies),
            ...Object.values(toolsWithoutPolicies),
        ]);
    }
    /**
     * Executes a tool with the provided parameters.
     * @param params - The parameters for tool execution, excluding session signatures.
     * @returns A promise that resolves to the tool execution response.
     * @throws If the execution fails or if the delegatee is not properly initialized.
     */
    async executeTool(params) {
        if (!this.litNodeClient || !this.litContracts || !this.delegateeWallet) {
            throw new Error('Delegatee not properly initialized');
        }
        const capacityCreditInfo = await Delegatee.getCapacityCredit(this.litContracts, this.storage, this.delegateeWallet.address);
        let capacityDelegationAuthSig;
        if (capacityCreditInfo !== null) {
            capacityDelegationAuthSig = (await this.litNodeClient.createCapacityDelegationAuthSig({
                dAppOwnerWallet: this.delegateeWallet,
                capacityTokenId: capacityCreditInfo.capacityTokenId,
                delegateeAddresses: [this.delegateeWallet.address],
                uses: '1',
            })).capacityDelegationAuthSig;
        }
        const sessionSignatures = await this.litNodeClient.getSessionSigs({
            chain: 'ethereum',
            expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes
            capabilityAuthSigs: capacityDelegationAuthSig !== undefined
                ? [capacityDelegationAuthSig]
                : undefined,
            resourceAbilityRequests: [
                {
                    resource: new auth_helpers_1.LitActionResource('*'),
                    ability: constants_1.LIT_ABILITY.LitActionExecution,
                },
                {
                    resource: new auth_helpers_1.LitPKPResource('*'),
                    ability: constants_1.LIT_ABILITY.PKPSigning,
                },
            ],
            authNeededCallback: async ({ uri, expiration, resourceAbilityRequests, }) => {
                const toSign = await (0, auth_helpers_1.createSiweMessage)({
                    uri,
                    expiration,
                    resources: resourceAbilityRequests,
                    walletAddress: await this.delegateeWallet.getAddress(),
                    nonce: await this.litNodeClient.getLatestBlockhash(),
                    litNodeClient: this.litNodeClient,
                });
                return await (0, auth_helpers_1.generateAuthSig)({
                    signer: this.delegateeWallet,
                    toSign,
                });
            },
        });
        try {
            return this.litNodeClient.executeJs({
                ...params,
                sessionSigs: sessionSignatures,
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to execute tool: ${error.message}`);
            }
            throw error;
        }
    }
    /**
     * Retrieves stored credentials required by a tool.
     * @param requiredCredentialNames - Names of the required credentials.
     * @returns Object containing found credentials and list of any missing credentials.
     */
    async getCredentials(requiredCredentialNames) {
        const delegatees = Delegatee.loadDelegateesFromStorage(this.storage);
        const storedCredentials = delegatees[this.delegateeWallet.address]?.credentials || {};
        const foundCredentials = {};
        const missingCredentials = [];
        for (const credentialName of requiredCredentialNames) {
            const storedCred = storedCredentials[credentialName];
            if (storedCred) {
                foundCredentials[credentialName] = storedCred;
            }
            else {
                missingCredentials.push(credentialName);
            }
        }
        return {
            foundCredentials: foundCredentials,
            missingCredentials,
        };
    }
    /**
     * Stores credentials for future tool executions.
     * @param credentials - Object containing credential key-value pairs to store.
     * @throws If any credential value is not a string.
     */
    async setCredentials(credentials) {
        const delegatees = Delegatee.loadDelegateesFromStorage(this.storage);
        if (!delegatees[this.delegateeWallet.address]) {
            delegatees[this.delegateeWallet.address] = {
                privateKey: this.delegateeWallet.privateKey.toString(),
            };
        }
        // Initialize credentials object if it doesn't exist
        if (!delegatees[this.delegateeWallet.address].credentials) {
            delegatees[this.delegateeWallet.address].credentials = {};
        }
        for (const [key, value] of Object.entries(credentials)) {
            if (typeof value === 'string') {
                delegatees[this.delegateeWallet.address].credentials[key] = value;
            }
            else {
                throw new Error(`Invalid credential value for ${key}: value must be a string`);
            }
        }
        Delegatee.saveDelegateesToStorage(this.storage, delegatees);
    }
    /**
     * Disconnects the Lit node client.
     */
    disconnect() {
        this.litNodeClient.disconnect();
    }
}
exports.Delegatee = Delegatee;
