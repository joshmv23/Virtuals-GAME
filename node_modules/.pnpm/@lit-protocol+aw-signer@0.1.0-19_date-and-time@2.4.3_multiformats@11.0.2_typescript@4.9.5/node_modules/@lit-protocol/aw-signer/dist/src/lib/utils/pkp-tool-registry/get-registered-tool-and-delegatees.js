"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRegisteredToolsAndDelegatees = void 0;
const tslib_1 = require("tslib");
const aw_tool_registry_1 = require("@lit-protocol/aw-tool-registry");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
/**
 * Process delegatee policies for a tool
 */
const processDelegateePolicies = (toolInfo) => {
    return toolInfo.delegatees.reduce((acc, delegatee, i) => {
        if (toolInfo.delegateesPolicyIpfsCids[i] !== '') {
            acc[delegatee] = {
                policyIpfsCid: toolInfo.delegateesPolicyIpfsCids[i],
                policyEnabled: toolInfo.delegateesPolicyEnabled[i],
            };
        }
        return acc;
    }, {});
};
/**
 * Process a tool that isn't found in the registry
 */
const processUnknownTool = (toolInfo, hasPolicies, result) => {
    if (hasPolicies) {
        const delegateePolicies = processDelegateePolicies(toolInfo);
        result.toolsUnknownWithPolicies[toolInfo.toolIpfsCid] = {
            toolEnabled: toolInfo.toolEnabled,
            delegateePolicies,
            delegatees: toolInfo.delegatees,
        };
    }
    else {
        result.toolsUnknownWithoutPolicies.push(toolInfo.toolIpfsCid);
    }
};
/**
 * Process a tool that is found in the registry
 */
const processKnownTool = (toolInfo, hasPolicies, registryTool, result) => {
    if (hasPolicies) {
        const delegateePolicies = processDelegateePolicies(toolInfo);
        result.toolsWithPolicies[toolInfo.toolIpfsCid] = {
            ...registryTool.tool,
            network: registryTool.network,
            toolEnabled: toolInfo.toolEnabled,
            delegatees: toolInfo.delegatees,
            delegateePolicies,
        };
    }
    else {
        result.toolsWithoutPolicies[toolInfo.toolIpfsCid] = {
            ...registryTool.tool,
            network: registryTool.network,
            toolEnabled: toolInfo.toolEnabled,
            delegatees: toolInfo.delegatees,
        };
    }
};
/**
 * Process a single tool from the registry
 */
const processRegistryTool = async (toolInfo, result) => {
    const hasPolicies = toolInfo.delegatees.length > 0;
    const registryTool = await (0, aw_tool_registry_1.getToolByIpfsCid)(toolInfo.toolIpfsCid);
    if (registryTool === null) {
        processUnknownTool(toolInfo, hasPolicies, result);
    }
    else {
        processKnownTool(toolInfo, hasPolicies, registryTool, result);
    }
};
/**
 * Process tools that are permitted but not in the registry response
 */
const processPermittedTools = async (permittedTools, toolsInfo, result) => {
    await Promise.all(permittedTools
        .filter((tool) => !toolsInfo.some((info) => info.toolIpfsCid === tool))
        .map(async (ipfsCid) => {
        const registryTool = await (0, aw_tool_registry_1.getToolByIpfsCid)(ipfsCid);
        if (registryTool === null) {
            result.toolsUnknownWithoutPolicies.push(ipfsCid);
        }
        else {
            const toolInfo = toolsInfo.find((info) => info.toolIpfsCid === ipfsCid);
            result.toolsWithoutPolicies[ipfsCid] = {
                ...registryTool.tool,
                network: registryTool.network,
                delegatees: toolInfo ? toolInfo.delegatees : [],
            };
        }
    }));
};
/**
 * Get all registered tools and categorize them based on whether they have policies
 * @returns Object containing:
 * - toolsWithPolicies: Object mapping tool IPFS CIDs to their metadata and delegatee policies
 * - toolsWithoutPolicies: Object mapping tool IPFS CIDs to their metadata without policies
 * - toolsUnknownWithPolicies: Object mapping unknown tool IPFS CIDs to their delegatee policies
 * - toolsUnknownWithoutPolicies: Array of tool CIDs without policies that aren't in the registry
 */
const getRegisteredToolsAndDelegatees = async (toolPolicyRegistryContract, litContracts, pkpTokenId) => {
    // Get all permitted tools from PKP Permissions contract
    const permittedTools = await litContracts.pkpPermissionsContractUtils.read.getPermittedActions(pkpTokenId);
    // Convert hex CIDs to base58
    const base58PermittedTools = permittedTools.map((hexCid) => {
        // Remove '0x' prefix and convert to Buffer
        const bytes = Buffer.from(hexCid.slice(2), 'hex');
        return bs58_1.default.encode(bytes);
    });
    // Get tools and their policies from registry contract
    const toolsInfo = await toolPolicyRegistryContract.getAllRegisteredToolsAndDelegatees(pkpTokenId);
    const result = {
        toolsWithPolicies: {},
        toolsWithoutPolicies: {},
        toolsUnknownWithPolicies: {},
        toolsUnknownWithoutPolicies: [],
    };
    // Process each tool from the registry
    await Promise.all(toolsInfo.map((toolInfo) => processRegistryTool(toolInfo, result)));
    // Process permitted tools that aren't in the registry
    await processPermittedTools(base58PermittedTools, toolsInfo, result);
    return result;
};
exports.getRegisteredToolsAndDelegatees = getRegisteredToolsAndDelegatees;
