"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aw_tool_1 = require("@lit-protocol/aw-tool");
const get_erc20_info_1 = require("./utils/get-erc20-info");
const get_gas_data_1 = require("./utils/get-gas-data");
const estimate_gas_limit_1 = require("./utils/estimate-gas-limit");
const create_and_sign_tx_1 = require("./utils/create-and-sign-tx");
const broadcast_tx_1 = require("./utils/broadcast-tx");
(async () => {
    try {
        console.log(`Using Lit Network: ${LIT_NETWORK}`);
        console.log(`Using PKP Tool Registry Address: ${PKP_TOOL_REGISTRY_ADDRESS}`);
        console.log(`Using Pubkey Router Address: ${aw_tool_1.NETWORK_CONFIG[LIT_NETWORK]
            .pubkeyRouterAddress}`);
        const delegateeAddress = ethers.utils.getAddress(LitAuth.authSigAddress);
        const toolIpfsCid = LitAuth.actionIpfsIds[0];
        const provider = new ethers.providers.JsonRpcProvider(params.rpcUrl);
        const pkpToolRegistryContract = await (0, aw_tool_1.getPkpToolRegistryContract)(PKP_TOOL_REGISTRY_ADDRESS);
        const pkp = await (0, aw_tool_1.getPkpInfo)(params.pkpEthAddress);
        const tokenInfo = await (0, get_erc20_info_1.getTokenInfo)(provider, params.tokenIn, pkp.ethAddress);
        console.log(`Token info: ${JSON.stringify(tokenInfo)}`);
        const toolPolicy = await (0, aw_tool_1.fetchToolPolicyFromRegistry)(pkpToolRegistryContract, pkp.tokenId, delegateeAddress, toolIpfsCid);
        if (toolPolicy.enabled &&
            toolPolicy.policyIpfsCid !== undefined &&
            toolPolicy.policyIpfsCid !== '0x' &&
            toolPolicy.policyIpfsCid !== '') {
            console.log(`Executing policy ${toolPolicy.policyIpfsCid}`);
            const policyParams = {
                parentToolIpfsCid: toolIpfsCid,
                pkpToolRegistryContractAddress: PKP_TOOL_REGISTRY_ADDRESS,
                pkpTokenId: pkp.tokenId,
                delegateeAddress,
                tokenInfo: {
                    amount: tokenInfo.amount.toString(),
                    tokenAddress: params.tokenIn,
                    recipientAddress: params.recipientAddress,
                },
            };
            console.log(`Calling policy Lit Action with params: ${JSON.stringify(policyParams)}`);
            await Lit.Actions.call({
                ipfsId: toolPolicy.policyIpfsCid,
                params: policyParams,
            });
        }
        else {
            console.log(`No policy found for tool ${toolIpfsCid} on PKP ${pkp.tokenId} for delegatee ${delegateeAddress}`);
        }
        const gasData = await (0, get_gas_data_1.getGasData)(provider, pkp.ethAddress);
        const gasLimit = await (0, estimate_gas_limit_1.estimateGasLimit)(provider, tokenInfo.amount, pkp.ethAddress);
        const signedTx = await (0, create_and_sign_tx_1.createAndSignTransaction)(params.tokenIn, params.recipientAddress, tokenInfo.amount, gasLimit, gasData, params.chainId, pkp.publicKey);
        const result = await (0, broadcast_tx_1.broadcastTransaction)(provider, signedTx);
        // Try to parse the result
        let parsedResult;
        try {
            parsedResult = JSON.parse(result);
        }
        catch {
            // If it's not JSON, assume it's a transaction hash
            parsedResult = result;
        }
        // Check if result is an error object
        if (typeof parsedResult === 'object' && parsedResult.error) {
            throw new Error(parsedResult.message);
        }
        // At this point, result should be a transaction hash
        if (!parsedResult) {
            throw new Error('Transaction failed: No transaction hash returned');
        }
        if (!ethers.utils.isHexString(parsedResult)) {
            throw new Error(`Transaction failed: Invalid transaction hash format. Received: ${JSON.stringify(parsedResult)}`);
        }
        Lit.Actions.setResponse({
            response: JSON.stringify({
                status: 'success',
                transferHash: parsedResult,
            }),
        });
    }
    catch (err) {
        console.error('Error:', err);
        // Extract detailed error information
        const errorDetails = {
            message: err.message,
            code: err.code,
            reason: err.reason,
            error: err.error,
            ...(err.transaction && { transaction: err.transaction }),
            ...(err.receipt && { receipt: err.receipt }),
        };
        // Construct a detailed error message
        const errorMessage = err.message || String(err);
        Lit.Actions.setResponse({
            response: JSON.stringify({
                status: 'error',
                error: errorMessage,
                details: errorDetails,
            }),
        });
    }
})();
