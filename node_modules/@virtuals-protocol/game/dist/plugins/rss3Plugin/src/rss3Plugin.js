"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const game_1 = require("@virtuals-protocol/game");
const sdk_1 = require("@rss3/sdk");
class RSS3Plugin {
    constructor(options) {
        this.id = options.id || "rss3_worker";
        this.name = options.name || "RSS3 Worker";
        this.description =
            options.description || "A worker capable of accessing real-time activities via RSS3 Network, including blockchains (for dApps) and decentralized protocols (ActivityPub and RSS). The activities are structured to be consumed by Agents.";
    }
    getWorker(data) {
        return new game_1.GameWorker({
            id: this.id,
            name: this.name,
            description: this.description,
            functions: (data === null || data === void 0 ? void 0 : data.functions) || [
                this.getCryptoNewsFunction,
                this.getActivitiesFunction
            ]
        });
    }
    get getCryptoNewsFunction() {
        return new game_1.GameFunction({
            name: "get_crypto_news",
            description: "Get the latest crypto news structured for AI Agents from RSS3 Network",
            args: [{ name: "limit", description: "Limit the number of activities to retrieve" }],
            executable: (args, logger) => __awaiter(this, void 0, void 0, function* () {
                try {
                    logger('Retrieving the latest crypto news');
                    let rss3AIEndpoint = 'https://ai.rss3.io/api/v1/ai_intel';
                    if (args.limit) {
                        rss3AIEndpoint += `?limit=${args.limit}`;
                    }
                    const intel = yield (yield fetch(rss3AIEndpoint)).json();
                    const cryptoNews = `crypto news fetched:\n${JSON.stringify(intel, null, 2)}`;
                    logger(cryptoNews);
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, cryptoNews);
                }
                catch (e) {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to retrieve the latest crypto news, please try again.");
                }
            }),
        });
    }
    get getActivitiesFunction() {
        return new game_1.GameFunction({
            name: "get_activities",
            description: "Get Activities from RSS3 Network",
            args: [{ name: "account", description: "The account to query for" }, { name: "tag", description: "The tag to filter" }, { name: "type", description: "The type to filter" }, { name: "network", description: "The network to filter" }, { name: "platform", description: "The platform to filter" }, { name: "limit", description: "Limit the number of activities to retrieve" }],
            executable: (args, logger) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!args.account) {
                        return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "An account is required");
                    }
                    logger(`Retrieving activities for: ${args.account}`);
                    let activities;
                    try {
                        const response = yield (0, sdk_1.getActivities)({
                            account: args.account,
                            tag: args.tag ? [args.tag] : undefined,
                            type: args.type ? [args.type] : undefined,
                            network: args.network ? [args.network] : undefined,
                            platform: args.platform ? [args.platform] : undefined,
                            limit: typeof args.platform === 'number' ? args.platform : 10,
                        });
                        activities = response.data;
                    }
                    catch (e) {
                        return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to retrieve activities, please check your arguments.");
                    }
                    const activitiesMessage = `Activities found:\n${JSON.stringify(activities, null, 2)}`;
                    logger(activitiesMessage);
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, activitiesMessage);
                }
                catch (e) {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to retrieve activities");
                }
            }),
        });
    }
}
exports.default = RSS3Plugin;
