"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnsoWorker = getEnsoWorker;
const sdk_1 = require("@ensofinance/sdk");
const game_1 = require("@virtuals-protocol/game");
const viem_1 = require("viem");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
function getEnsoWorker(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const ensoClient = new sdk_1.EnsoClient({ apiKey: params.apiKey });
        const chainId = yield params.publicClient.getChainId();
        return new game_1.GameWorker({
            id: "enso_worker",
            name: "Enso worker",
            description: "Worker that finds the best route from token to token and executes it",
            functions: [
                ensoRoute({
                    ensoClient,
                    wallet: params.wallet,
                    publicClient: params.publicClient,
                }),
            ],
            getEnvironment: () => __awaiter(this, void 0, void 0, function* () {
                return {
                    chainId,
                    networkName: constants_1.ENSO_SUPPORTED_CHAINS.get(chainId),
                };
            }),
        });
    });
}
function ensoRoute(params) {
    return new game_1.GameFunction({
        name: "enso_route",
        description: "Find the best route from a token to another token on specified blockchain network in environment and execute it",
        args: [
            {
                name: "tokenIn",
                type: "string",
                description: "Token to swap from. Use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee for native token. Make sure that the address is for the correct blockchain network",
            },
            {
                name: "tokenOut",
                type: "string",
                description: "Token to swap to. Use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee for native token. Make sure that the address is for the correct blockchain network",
            },
            {
                name: "amountIn",
                type: "string",
                description: "Amount of tokenIn in formatted structure",
            },
        ],
        executable: (_a, logger_1) => __awaiter(this, [_a, logger_1], void 0, function* ({ tokenIn, tokenOut, amountIn }, logger) {
            if (!tokenIn) {
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Token in is required");
            }
            if (!tokenOut) {
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Token out is required");
            }
            if (!amountIn) {
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Amount in is required");
            }
            const chainId = yield params.wallet.getChainId();
            if (!constants_1.ENSO_SUPPORTED_CHAINS.has(chainId)) {
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Chain ${chainId} is not supported`);
            }
            const [sender] = yield params.wallet.getAddresses();
            try {
                if (!params.wallet.account) {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Wallet account is missing`);
                }
                const tokenInRes = yield params.ensoClient.getTokenData({
                    chainId,
                    address: tokenIn,
                    includeMetadata: true,
                });
                if (tokenInRes.data.length === 0 ||
                    typeof tokenInRes.data[0].decimals !== "number") {
                    return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Token ${tokenIn} is not supported`);
                }
                const tokenInData = tokenInRes.data[0];
                const amountInWei = (0, viem_1.parseUnits)(amountIn, tokenInData.decimals);
                const routeParams = {
                    chainId,
                    tokenIn: tokenIn,
                    tokenOut: tokenOut,
                    amountIn: amountInWei.toString(),
                    fromAddress: sender,
                    receiver: sender,
                    spender: sender,
                };
                logger(`Fetching the best route...`);
                const routeData = yield params.ensoClient.getRouterData(routeParams);
                logger(`Successfully found the best route:\n\n${(0, utils_1.buildRoutePath)(routeData.route)}\n`);
                if (tokenIn.toLowerCase() !== constants_1.ENSO_ETH) {
                    logger(`Approving ${tokenInData.symbol}...`);
                    const { request, result } = yield params.publicClient.simulateContract({
                        address: tokenIn,
                        abi: constants_1.ERC20_ABI_MIN,
                        functionName: "approve",
                        args: [routeData.tx.to, BigInt(amountInWei)],
                        account: params.wallet.account,
                    });
                    logger(`Approve simulation done, result: ${result}`);
                    const txHash = yield params.wallet.writeContract(request);
                    logger(`Approve transaction submitted: ${txHash}`);
                    yield params.publicClient.waitForTransactionReceipt({
                        hash: txHash,
                    });
                    logger(`Approve successful`);
                }
                logger(`Executing route...`);
                const txHash = yield params.wallet.sendTransaction({
                    account: params.wallet.account,
                    data: routeData.tx.data,
                    to: routeData.tx.to,
                    value: BigInt(routeData.tx.value),
                });
                logger(`Route execution submitted: ${txHash}`);
                yield params.publicClient.waitForTransactionReceipt({
                    hash: txHash,
                });
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Route executed succesfully, hash: ${txHash}`);
            }
            catch (err) {
                return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, `Failed execute route from Enso API: ${err}`);
            }
        }),
    });
}
