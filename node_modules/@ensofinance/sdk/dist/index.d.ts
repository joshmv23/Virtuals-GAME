type RoutingStrategy = "router" | "delegate" | "ensowallet";
type Address = `0x${string}`;
type MultiAddress = Address | Address[];
type RouteParams = {
    fromAddress: Address;
    receiver: Address;
    spender: Address;
    chainId: number;
    amountIn: string;
    slippage?: number;
    minAmountOut?: string;
    tokenIn: Address;
    tokenOut: Address;
    routingStrategy?: RoutingStrategy;
    fee?: number;
    feeReceiver?: Address;
};
type RouteSegment = {
    action: string;
    protocol: string;
    primary?: Address;
    tokenIn: Address[];
    tokenOut: Address[];
    positionInId?: string[];
    positionOutId?: string[];
    internalRoutes?: RouteSegment[][];
};
type RouteData = {
    route: RouteSegment[];
    gas: number;
    amountOut: number;
    priceImpact: number | null;
    createdAt: number;
    tx: {
        data: string;
        to: Address;
        from: Address;
        value: string;
    };
    feeAmount: {
        [key: string]: number;
    }[];
};
type ApproveParams = {
    fromAddress: Address;
    tokenAddress: Address;
    chainId: number;
    amount: string;
    routingStrategy?: RoutingStrategy;
};
type ApproveData = {
    amount: string;
    gas: string;
    spender: Address;
    token: Address;
    tx: {
        data: string;
        from: Address;
        to: Address;
    };
};
type QuoteParams = Omit<RouteParams, "spender" | "receiver" | "slippage">;
type QuoteData = {
    amountOut: string;
    gas: string;
    priceImpact: number;
};
type BalanceParams = {
    chainId: number;
    eoaAddress: Address;
    useEoa?: boolean;
};
type BalanceData = {
    amount: string;
    decimals: number;
    token: Address;
    price: string;
};
type TokenParams = {
    address?: MultiAddress;
    underlyingTokens?: MultiAddress;
    protocolSlug?: string;
    type?: "defi" | "base";
    includeMetadata?: boolean;
    chainId: number;
};
type Token = {
    address: Address;
    chainId: number;
    decimals: number;
    name: string;
    symbol: string;
    logosUri: string[];
    type: "defi" | "base";
};
type TokenData = Token & {
    protocolSlug: string;
    underlyingTokens: Token[];
    primaryAddress: Address;
    apy: number | null;
};
type PriceParams = {
    chainId: number;
    address: Address;
};
type PriceData = {
    price: string;
    decimals: number;
    symbol: string;
    timestamp: number;
    confidence: number;
};
type ProtocolParams = {
    slug?: string;
};
type ProtocolData = {
    chains: {
        name: string;
        id: number;
    }[];
    name: string | null;
    description: string | null;
    slug: string;
    url: string;
    logosUri: string[];
};

declare class EnsoClient {
    private client;
    constructor({ baseURL, apiKey, }: {
        baseURL?: string;
        apiKey: string;
    });
    private request;
    getApprovalData(params: ApproveParams): Promise<ApproveData>;
    getRouterData(params: RouteParams): Promise<RouteData>;
    getQuoteData(params: QuoteParams): Promise<QuoteData>;
    getBalances(params: BalanceParams): Promise<BalanceData[]>;
    getTokenData(params: TokenParams): Promise<{
        data: TokenData[];
    }>;
    getPriceData(params: PriceParams): Promise<PriceData>;
    getProtocolData(params?: ProtocolParams): Promise<ProtocolData[]>;
}

export { type ApproveData, type ApproveParams, type BalanceData, type BalanceParams, EnsoClient, type PriceData, type PriceParams, type ProtocolData, type ProtocolParams, type QuoteData, type QuoteParams, type RouteData, type RouteParams, type TokenData, type TokenParams };
